import fs from 'fs';
import { dirname, join } from 'path';
import { CliUx, Command, Flags } from '@oclif/core';
import got from 'got';
import { getProjectConfigWizard } from '../../wizards/get-project-config.js';
import { select } from '../../wizards/select.js';
const PLUGIN_BASE = 'https://raw.githubusercontent.com/steamship-plugins/plugin-base-template/main';
function pluginFile(local_path) {
    return {
        url: `${PLUGIN_BASE}/${local_path}`,
        local_path: local_path
    };
}
const PLUGIN_TESTING = pluginFile('TESTING.md');
const PLUGIN_DEVELOPING = pluginFile('DEVELOPING.md');
const PLUGIN_DEPLOYING = pluginFile('DEPLOYING.md');
const PLUGIN_GITIGNORE = pluginFile('.gitignore');
const PLUGIN_DEPLOY_ACTION = pluginFile('.github/workflows/deploy.yml');
const PLUGIN_TEST_ACTION = pluginFile('.github/workflows/test.yml');
const PLUGIN_FILES = [
    PLUGIN_TESTING,
    PLUGIN_DEVELOPING,
    PLUGIN_DEPLOYING,
    PLUGIN_GITIGNORE,
    PLUGIN_DEPLOY_ACTION,
    PLUGIN_TEST_ACTION
];
const APP_FILES = [PLUGIN_GITIGNORE, PLUGIN_DEPLOY_ACTION, PLUGIN_TEST_ACTION];
export async function getCollisionChoice(newFile, proposeFile) {
    const choices = [
        { id: 'skip', name: 'Skip', description: 'Skip updating this file.' },
        { id: 'propose', name: 'Propose', description: `Propose changes safely in ${proposeFile}.` },
        { id: 'overwrite', name: 'Overwrite', description: 'Overwrite your existing file.' }
    ];
    return (await select({
        prompt: `File ${newFile} already exists and differs. What would you like to do?`,
        choices
    })).id;
}
export default class SyncDocs extends Command {
    static description = 'Syncs standardized documentation and settings. Will not overwrite without asking.';
    static examples = [
        'ship util:sync-docs',
        'ship util:sync-docs --simulate',
        'ship util:sync-docs --all=skip|overwrite|propose'
    ];
    static flags = {
        help: Flags.help(),
        simulate: Flags.boolean({ char: 's', description: 'only simulate the sync' }),
        all: Flags.string({
            char: 'a',
            description: 'skip|overwrite|propose - auto-apply to conflicts'
        })
    };
    static args = [];
    exists(dest, file) {
        return fs.existsSync(join(dest, file.local_path));
    }
    async copy(dest, file, remoteFile) {
        const destPath = join(dest, file.local_path);
        const destFolder = dirname(destPath);
        await fs.promises.mkdir(destFolder, { recursive: true });
        fs.writeFileSync(destPath, remoteFile);
    }
    async syncFile(dest, file, simulate, collisionChoice) {
        const remoteFileResp = await got(file.url).catch((e) => e);
        if (remoteFileResp.statusCode !== 200) {
            CliUx.ux.error(`Error fetching file: ${file.url}`);
        }
        const remoteFile = remoteFileResp.body;
        if (this.exists(dest, file)) {
            const localFile = fs.readFileSync(join(dest, file.local_path));
            if (localFile == remoteFile) {
                CliUx.ux.info(`[ SAME      ] ${file.local_path}`);
                return;
            }
            const parts = file.local_path.split('.');
            parts.push(parts[parts.length - 1]);
            parts[parts.length - 2] = 'proposed';
            const proposal = parts.join('.');
            const choice = typeof collisionChoice == 'undefined'
                ? await getCollisionChoice(file.local_path, proposal)
                : collisionChoice;
            if (choice == 'overwrite') {
                CliUx.ux.info(`[ OVERWRITE ] ${file.local_path} <- ${file.url}`);
                if (simulate != true) {
                    this.copy(dest, file, remoteFile);
                }
            }
            else if (choice == 'propose') {
                CliUx.ux.info(`[ PROPOSE   ] ${proposal} <- ${file.url}`);
                if (simulate != true) {
                    const file2 = file;
                    file2.local_path = proposal;
                    this.copy(dest, file2, remoteFile);
                }
            }
            else {
                CliUx.ux.info(`[ SKIP      ] ${file.local_path}`);
            }
        }
        else {
            CliUx.ux.info(`[ COPY      ] ${file.local_path} <- ${file.url}`);
            if (simulate != true) {
                this.copy(dest, file, remoteFile);
            }
        }
    }
    async syncFiles(dest, files, simulate, collisionChoice) {
        for (const file of files) {
            await this.syncFile(dest, file, simulate, collisionChoice);
        }
    }
    async run() {
        const { args, flags } = await this.parse(SyncDocs);
        const config = await getProjectConfigWizard({
            checkHandle: true,
            checkVersion: true,
            checkType: true,
            checkEntrypoint: true,
            checkPluginParams: true,
            willDeploy: true
        });
        const dest = process.cwd();
        if (config.type == 'plugin') {
            this.syncFiles(dest, PLUGIN_FILES, flags.simulate === true, flags.all);
        }
        else if (config.type == 'package') {
            this.syncFiles(dest, APP_FILES);
        }
        else {
            CliUx.ux.error('Document synchronization is currently only available for package and plugin projects.');
        }
    }
}
