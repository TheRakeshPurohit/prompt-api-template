import fs from 'fs';
import path from 'path';
import { CliUx } from '@oclif/core';
import archiver from 'archiver';
import del from 'del';
import { getProjectConfigWizard } from '../wizards/get-project-config.js';
const DEFAULT_BUILD_IGNORE = ['build', '.git', '.venv', '.ipynb_checkpoints', '.DS_Store', 'venv'];
export async function bundlePackage() {
    CliUx.ux.log('Bundling package');
    const appPackage = await getProjectConfigWizard();
    const currentDir = process.cwd();
    const zipName = `${appPackage.handle}_v${appPackage.version}.zip`;
    const archivesLocation = path.join(currentDir, 'build/archives');
    const zipLocation = path.join(archivesLocation, zipName);
    if (fs.existsSync(zipLocation)) {
        await del(zipLocation);
    }
    fs.mkdirSync(archivesLocation, { recursive: true });
    const this_ignore = appPackage?.build_config?.ignore ? appPackage?.build_config?.ignore : [];
    const disallowedItems = this_ignore.concat(DEFAULT_BUILD_IGNORE);
    let sourceItems = fs.readdirSync(currentDir);
    sourceItems = sourceItems.filter((item) => !disallowedItems.includes(item));
    const sourceFolders = sourceItems.filter((p) => fs.lstatSync(path.join(currentDir, p)).isDirectory());
    const sourceFiles = sourceItems.filter((p) => fs.lstatSync(path.join(currentDir, p)).isFile());
    const archive = archiver('zip', { zlib: { level: 9 } });
    const stream = fs.createWriteStream(zipLocation);
    fs.mkdirSync(archivesLocation, { recursive: true });
    await new Promise((resolve, reject) => {
        sourceFolders.forEach((dir) => {
            archive.directory(path.join(currentDir, dir), false);
        });
        sourceFiles.forEach((file) => {
            archive.file(path.join(currentDir, file), { name: file });
        });
        archive.pipe(stream);
        stream.on('close', () => {
            resolve();
        });
        archive.finalize();
    });
    CliUx.ux.log('------------------------------------------------------------------');
    return zipLocation;
}
