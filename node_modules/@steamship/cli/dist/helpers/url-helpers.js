import { CliUx } from '@oclif/core';
import retry from 'async-retry';
import chalk from 'chalk';
import { downloadAndExtractExample, downloadAndExtractRepo, exampleCheckUrl, getRepoInfo, getRepoInfoFromUrlString, gzipUrl, hasExample, hasRepo } from './examples.js';
export var TemplateType;
(function (TemplateType) {
    TemplateType[TemplateType["Empty"] = 0] = "Empty";
    TemplateType[TemplateType["GitHub"] = 1] = "GitHub";
    TemplateType[TemplateType["DeepGithub"] = 2] = "DeepGithub";
    TemplateType[TemplateType["Url"] = 3] = "Url";
    TemplateType[TemplateType["Error"] = 4] = "Error";
    TemplateType[TemplateType["Name"] = 5] = "Name";
})(TemplateType || (TemplateType = {}));
export class Template {
    type;
    origValue;
    url;
    exampleName;
    repoInfo;
    constructor(urlOrString) {
        this.origValue = urlOrString;
        if (typeof urlOrString == 'undefined') {
            this.type = TemplateType.Empty;
            return;
        }
        if (typeof urlOrString == 'string' && urlOrString.trim().length == 0) {
            this.type = TemplateType.Empty;
            return;
        }
        try {
            const repoUrl = typeof urlOrString == 'string' ? new URL(urlOrString) : urlOrString;
            if (repoUrl.origin !== 'https://github.com' && repoUrl.origin !== 'https://www.github.com') {
                this.type = TemplateType.Url;
                this.url = repoUrl;
            }
            else {
                const parts = repoUrl.pathname.split('/');
                if (parts.length == 3) {
                    this.type = TemplateType.GitHub;
                    this.url = repoUrl;
                }
                else if (parts.length < 3) {
                    CliUx.ux.error(`Unable to parse URL: ${urlOrString}`);
                }
                else {
                    this.type = TemplateType.DeepGithub;
                    this.repoInfo = getRepoInfoFromUrlString(repoUrl);
                }
            }
            return;
        }
        catch (error) {
            if (error.code !== 'ERR_INVALID_URL') {
                this.type = TemplateType.Error;
                CliUx.ux.error(`${error}`);
                return;
            }
        }
        this.type = TemplateType.Name;
        this.exampleName = urlOrString;
    }
    async prepare() {
        if (this.type == TemplateType.Empty) {
            CliUx.ux.error('Unsure which template to install');
        }
        if (this.type == TemplateType.Url) {
            CliUx.ux.error(`Invalid URL: ${chalk.red(`"${this.origValue}"`)}. Only GitHub repositories are supported. Please use a GitHub URL and try again.`);
        }
        if (this.type == TemplateType.GitHub) {
            if (typeof this.url == 'undefined') {
                CliUx.ux.error('Undefined GitHub repo URL');
            }
            else {
                await this.initRepoInfo(this.url);
            }
        }
        else if (this.type == TemplateType.Name) {
            if (typeof this.exampleName == 'undefined') {
                CliUx.ux.error('Undefined Template name');
            }
            else {
                await this.initExample(this.exampleName);
            }
        }
    }
    async initRepoInfo(url, repoPath) {
        const _repoInfo = await getRepoInfo(url, repoPath);
        if (!_repoInfo || typeof _repoInfo == 'undefined') {
            CliUx.ux.error(`Found invalid GitHub URL: ${chalk.red(`"${url}"`)}. Please fix the URL and try again.`);
        }
        const repoInfo = _repoInfo;
        const found = await hasRepo(repoInfo);
        if (!found) {
            CliUx.ux.error(`Could not locate the repository for ${chalk.red(`"${url}"`)}. Please check that the repository exists and try again.`);
        }
        this.repoInfo = repoInfo;
    }
    async downloadGitRepo(root) {
        if (typeof this.url == 'undefined') {
            CliUx.ux.error('Empty GitHub URL');
        }
        if (typeof this.repoInfo == 'undefined') {
            CliUx.ux.error('Empty RepoInfo');
        }
        CliUx.ux.log(`Downloading files from repo ${chalk.cyan(this.url)}. This might take a moment.`);
        await retry(() => downloadAndExtractRepo(root, this.repoInfo), {
            retries: 3
        });
    }
    async initExample(exampleName) {
        if (this.exampleName == '__internal-testing-retry') {
            return;
        }
        if (this.repoInfo) {
            return;
        }
        const userName = 'nludb';
        const repoName = 'nludb-examples';
        const branch = 'main';
        const repoPath = `examples/${exampleName}`;
        const url = gzipUrl(userName, repoName, branch);
        CliUx.ux.log(`Template path: ${chalk.cyan(url)}`);
        this.repoInfo = { userName, repoName, branch, repoPath };
    }
    async downloadExample(root) {
        if (typeof this.repoInfo == 'undefined') {
            CliUx.ux.error('Empty RepoInfo');
        }
        const { userName, repoName, branch, repoPath } = this.repoInfo;
        if (typeof userName == 'undefined') {
            CliUx.ux.error('Empty userName');
        }
        if (typeof repoName == 'undefined') {
            CliUx.ux.error('Empty repoName');
        }
        if (typeof branch == 'undefined') {
            CliUx.ux.error('Empty branch');
        }
        if (typeof repoPath == 'undefined') {
            CliUx.ux.error('Empty repoPath');
        }
        if (this.exampleName == '__internal-testing-retry') {
            return;
        }
        let found = false;
        try {
            found = await hasExample(userName, repoName, branch, repoPath);
            CliUx.ux.info('Found');
        }
        catch (e) {
            CliUx.ux.error(e);
        }
        if (!found) {
            const url = exampleCheckUrl(userName, repoName, branch, repoPath);
            CliUx.ux.error(`
      Could not find package file at ${chalk.red(url)}. 
      It could be due to the following:
        1. The template repository registration may be incorrect.
        2. The template may not contain the required package file.
        3. You might not be connected to the internet.`);
        }
        const url = gzipUrl(userName, repoName, branch);
        CliUx.ux.info(url);
        CliUx.ux.log(`Downloading archive ${chalk.cyan(this.exampleName)}.`);
        CliUx.ux.log(`This might take a moment.`);
        await retry(() => downloadAndExtractExample(root, userName, repoName, branch, repoPath), {
            retries: 3
        });
    }
}
export function parseUrl(url) {
    return new Template(url);
}
export function attachTrailingSlash(url) {
    if (url[url.length - 1] != '/') {
        return url + '/';
    }
    return url;
}
export function removeTrailingSlash(url) {
    if (url[url.length - 1] == '/') {
        return url.substring(0, url.length - 1);
    }
    return url;
}
