import { CliUx } from '@oclif/core';
import got from 'got';
import inquirer from 'inquirer';
export const STARTER_PACKAGE_LIST = 'https://raw.githubusercontent.com/steamship-packages/awesome-steamship-packages/main/packages.json';
export const STARTER_PLUGIN_LIST = 'https://raw.githubusercontent.com/steamship-plugins/awesome-steamship-plugins/main/plugins.json';
export const ProjectChoiceTree = {
    prompt: 'What kind of project would you like to create?',
    choices: [
        {
            id: 'package',
            name: 'Package',
            description: 'Full-stack natural language services you can import into any project.',
            choicesUrl: STARTER_PACKAGE_LIST
        },
        {
            id: 'plugin',
            name: 'Plugin',
            description: 'Extensions to Steamship for import, export, inference, and embedding.',
            choicesUrl: STARTER_PLUGIN_LIST
        },
        {
            id: 'project',
            name: 'Project',
            description: 'Create a Jupyter project using Steamship',
            choicesUrl: 'https://raw.githubusercontent.com/steamship-projects/awesome-steamship-projects/main/projects.json'
        }
    ]
};
async function getIdRecursive(choices, preSelected) {
    for (const c of choices) {
        if (c.id == preSelected) {
            return c;
        }
        if (c.choices && Array.isArray(c.choices)) {
            const r = getIdRecursive(c.choices, preSelected);
            if (r) {
                return r;
            }
        }
    }
}
function makeChoicePropertyFilter(limitToPropertyNotNull) {
    const returnFunction = (choice) => {
        if (choice.choicesUrl) {
            return true;
        }
        if (choice[limitToPropertyNotNull] !== null &&
            choice[limitToPropertyNotNull] !== undefined) {
            const value = choice[limitToPropertyNotNull];
            if (!(Array.isArray(value) && value.length == 0)) {
                return true;
            }
        }
        if (choice.choices?.choices) {
            for (const c of choice.choices.choices) {
                if (returnFunction(c)) {
                    return true;
                }
            }
        }
        return false;
    };
    return returnFunction;
}
export async function inquire(prompt, choices) {
    return new Promise((resolve, reject) => {
        const choiceList = choices.map((choice) => {
            return `${choice.name} - ${choice.description}`;
        });
        inquirer
            .prompt([
            {
                type: 'list',
                name: 'choice',
                message: prompt,
                choices: choiceList
            }
        ])
            .then((answers) => {
            const answer = answers['choice'];
            const idx = choiceList.indexOf(answer);
            resolve(choices[idx]);
        })
            .catch((error) => {
            if (error.isTtyError) {
                reject('Unable to render list of choices in your current TTY environment.');
            }
            else {
                reject(error);
            }
        });
    });
}
export async function select(params) {
    let { choices, limitToPropertyNotNull, preSelected, limitOptions, prompt, recurse, requirePreselect } = params;
    if (!choices) {
        throw Error('`choices` required to select choices.');
    }
    if (typeof limitToPropertyNotNull != 'undefined') {
        choices = choices.filter(makeChoicePropertyFilter(limitToPropertyNotNull));
    }
    if (choices.length == 0) {
        throw Error('No choices were found to choose from.');
    }
    if (preSelected) {
        const res = await getIdRecursive(choices, preSelected);
        if (res)
            return res;
        if (requirePreselect === true) {
            throw Error(`Unable to preselect value ${preSelected}`);
        }
    }
    if (limitOptions) {
        choices = choices.filter((choice) => choice.id && limitOptions?.includes(choice.id));
    }
    const selection = await inquire(prompt || 'Please make a selection:', choices);
    if (recurse === false) {
        return selection;
    }
    else if (selection.choices?.choices && Array.isArray(selection.choices?.choices)) {
        return selectFromJson({
            ...params,
            tree: selection.choices,
            url: undefined,
            choices: undefined,
            prompt: undefined,
            limitOptions: undefined
        });
    }
    else if (selection.choicesUrl) {
        return selectFromUrl({
            ...params,
            url: selection.choicesUrl,
            choices: undefined,
            tree: undefined,
            prompt: undefined,
            limitOptions: undefined
        });
    }
    else {
        return selection;
    }
}
export async function selectFromJson(params) {
    if (!params.tree) {
        throw Error(`'tree' required to select options from JSON. Got ${JSON.stringify(params)}`);
    }
    if (!params.tree.choices) {
        CliUx.ux.error(`Empty set of choices from choice selection tree with prompt: ${params.tree.prompt}`);
    }
    return select({
        ...params,
        choices: params.tree.choices,
        prompt: params.prompt || params.tree.prompt
    });
}
export async function selectFromUrl(params) {
    if (!params.url) {
        throw Error('`url` required to select options from URL list.');
    }
    const urlResponse = await got(params.url).catch((e) => e);
    if (urlResponse.statusCode !== 200) {
        CliUx.ux.error(`Error fetching remote selection tree from: ${params.url}`);
    }
    const json = JSON.parse(urlResponse.body);
    return selectFromJson({ ...params, tree: json });
}
export async function selectProject(params) {
    return selectFromJson({ ...params, tree: ProjectChoiceTree });
}
