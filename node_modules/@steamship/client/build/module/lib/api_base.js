function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
import axios from 'axios';
import getLogger from './log.js';
import { loadConfiguration } from './shared/Configuration.js';
import { SteamshipError } from './steamship_error.js';
import { Task } from './task.js';
import { TaskState } from './types/base.js';
import { isNode } from './utils.js';
function doFetch(_x, _x2) {
  return _doFetch.apply(this, arguments);
} // async function doFetch(url: any, opts: any): Promise<AxiosResponse> {
//   return new Promise<AxiosResponse>((resolve, reject) => {
//     axios({
//       url,
//       headers: opts.headers,
//       data: opts.body,
//       method: opts.method,
//     }).then(resolve)
//       .catch(
//         (err) => {
//           console.log(err);
//           reject(err);
//         }
//       )
//   })
// }
function _doFetch() {
  _doFetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(url, opts) {
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          return _context8.abrupt("return", axios({
            url: url,
            headers: opts.headers,
            data: opts.body,
            method: opts.method
          }));
        case 1:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  }));
  return _doFetch.apply(this, arguments);
}
var log = getLogger('Steamship:ApiBase');
var MAX_BODY_LENGTH = 100000 * 1000;
var _IS_LOCAL = function _IS_LOCAL(base) {
  for (var _i = 0, _arr = ['localhost', '127.0.0.1', '0:0:0:0', ':3000', 'steamship.local', 'host.docker.internal', '/test:', '//app.staging.steamship.com',
    // For the demo user proxy trick - this is the website proxy
    '//app.steamship.com' // For the demo user proxy trick - this is the website proxy
    ]; _i < _arr.length; _i++) {
    var s = _arr[_i];
    if (base.includes(s)) {
      return true;
    }
  }
  return false;
};

/* Should be a FormData object */
function addMultiparts(formData, path, value) {
  /* Decode any object into a series of HTTP Multi-part segments that Vapor will consume.
    https://github.com/vapor/multipart-kit
     When sending a JSON object in a MultiPart request, Vapor wishes to see multi part segments as follows:
    single_key
    array_key[idx]
    obj_key[prop]
     So a File with a list of one tag with kind=Foo would be transmitted as setting the part:
    [tags][0][kind]
  */
  var type = typeof value;
  if (type == 'string' || type == 'boolean' || type == 'number') {
    formData.append(path, value);
  } else if (Array.isArray(value)) {
    value.forEach(function (subValue, index) {
      addMultiparts(formData, path + "[" + index + "]", subValue);
    });
  } else {
    for (var _key in value) {
      addMultiparts(formData, path + "[" + _key + "]", value[_key]);
    }
  }
}
export var ApiBase = /*#__PURE__*/function () {
  function ApiBase(params) {
    var _this = this;
    _classCallCheck(this, ApiBase);
    _defineProperty(this, "config", void 0);
    this.config = loadConfiguration(params).then(function (config) {
      if (config.apiKey) {
        return _this._switchConfigWorkspace({
          workspaceHandle: params == null ? void 0 : params.workspace,
          failIfWorkspaceExists: (params == null ? void 0 : params.failIfWorkspaceExists) === true,
          config: config
        });
      } else {
        return config;
      }
    });
  }
  _createClass(ApiBase, [{
    key: "switchWorkspace",
    value: function () {
      var _switchWorkspace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
        var config;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = this;
              _context.t1 = _extends;
              _context.t2 = {};
              _context.t3 = params;
              _context.next = 6;
              return this.config;
            case 6:
              _context.t4 = _context.sent;
              _context.t5 = {
                config: _context.t4
              };
              _context.t6 = (0, _context.t1)(_context.t2, _context.t3, _context.t5);
              _context.next = 11;
              return _context.t0._switchConfigWorkspace.call(_context.t0, _context.t6);
            case 11:
              config = _context.sent;
              this.config = Promise.resolve(config);
              log.info("Switched to workspace " + config.workspaceHandle + "/" + config.workspaceId);
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function switchWorkspace(_x3) {
        return _switchWorkspace.apply(this, arguments);
      }
      return switchWorkspace;
    }()
    /*
      Switches this client to the requested workspace, possibly creating it. If all arguments are None, the client
      actively switches into the default workspace.
       - API calls are performed manually to not result in circular imports.
      - Note that the default workspace is technically not necessary for API usage; it will be assumed by the Engine
        in the absense of a Workspace ID or Handle being manually specified in request headers.
     */
  }, {
    key: "_switchConfigWorkspace",
    value: function () {
      var _switchConfigWorkspace2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
        var workspace, p, oldConfig, activeConfig, returnId, returnHandle;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              workspace = undefined;
              p = _extends({}, params);
              if (!p.workspaceHandle) {
                p.workspaceHandle = 'default';
              }
              if (p.failIfWorkspaceExists) {
                log.info("Creating workspace with handle: " + p.workspaceHandle + ".");
              } else {
                log.info("Creating/Fetching workspace with handle: " + p.workspaceHandle + ".");
              }

              // Zero out the workspace_handle on the config block in case we're being invoked from
              // `init` (otherwise we'll attempt to create the sapce IN that nonexistant workspace)
              oldConfig = params.config;
              activeConfig = _extends({}, oldConfig, {
                workspaceHandle: undefined,
                workspaceId: undefined
              });
              _context2.next = 8;
              return this.post('workspace/create', {
                handle: p.workspaceHandle,
                fetchIfExists: !(p.failIfWorkspaceExists === true)
              }, {
                responsePath: 'workspace'
              }, activeConfig);
            case 8:
              workspace = _context2.sent;
              if (!(!workspace || !workspace.output)) {
                _context2.next = 11;
                break;
              }
              throw new SteamshipError({
                statusMessage: 'Was unable to switch to new workspace: server returned empty Workspace.'
              });
            case 11:
              returnId = workspace.output.id;
              returnHandle = workspace.output.handle;
              if (!(!returnHandle || !returnId)) {
                _context2.next = 16;
                break;
              }
              log.error(workspace);
              throw new SteamshipError({
                statusMessage: JSON.stringify(workspace) + " Unable to switch to workspace " + p.workspaceHandle + " with failIfWorkspaceExists " + p.failIfWorkspaceExists + ": server returned empty ID and Handle."
              });
            case 16:
              return _context2.abrupt("return", _extends({}, oldConfig, {
                workspaceHandle: returnHandle,
                workspaceId: returnId
              }));
            case 17:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _switchConfigWorkspace(_x4) {
        return _switchConfigWorkspace2.apply(this, arguments);
      }
      return _switchConfigWorkspace;
    }()
  }, {
    key: "_headers",
    value: function _headers(config, postConfig) {
      var ret = {
        'Content-Type': 'application/json',
        Authorization: "Bearer " + config.apiKey
      };
      if (postConfig != null && postConfig.workspaceId) {
        ret['X-Workspace-Id'] = postConfig == null ? void 0 : postConfig.workspaceId;
      } else if (config.workspaceId) {
        ret['X-Workspace-Id'] = config.workspaceId;
      } else if (config.workspaceHandle) {
        ret['X-Workspace-Handle'] = config.workspaceHandle;
      }
      if ((postConfig == null ? void 0 : postConfig.isPackageCall) === true) {
        if (postConfig != null && postConfig.packageOwner) {
          ret['X-Package-Owner-Handle'] = postConfig.packageOwner;
        }
        if (postConfig != null && postConfig.packageId) {
          ret['X-Package-Id'] = postConfig.packageId;
        }
        if (postConfig != null && postConfig.packageInstanceId) {
          ret['X-Package-Instance-Id'] = postConfig.packageInstanceId;
        }
      }
      if ((postConfig == null ? void 0 : postConfig.asBackgroundTask) === true) {
        // Will result in the engine persisting the inbound HTTP request as a Task for deferred
        // execution. The client will receive task information back instead of the synchronous API response.
        // That task can be polled for eventual completion.
        ret['X-Task-Background'] = 'true';
      }
      return ret;
    }
  }, {
    key: "_url",
    value: function _url(baseConfig, postConfig, operation) {
      var base = '';
      if (!((postConfig == null ? void 0 : postConfig.isPackageCall) === true)) {
        // It's an API call
        base = (postConfig == null ? void 0 : postConfig.apiBase) || baseConfig.apiBase;
      } else {
        // It's a package call
        if (!(postConfig != null && postConfig.packageOwner)) {
          throw new SteamshipError({
            statusCode: 'UserMissing',
            statusMessage: "Can not invoke an package endpoint without the package owner's user handle.",
            statusSuggestion: 'Provide the packageOwner option, or initialize your package with a lookup.'
          });
        }
        base = (postConfig == null ? void 0 : postConfig.appBase) || baseConfig.appBase;
        if (!base) {
          throw new SteamshipError({
            statusCode: 'EndpointMissing',
            statusMessage: 'Can not invoke an package endpoint without the App Base variable set.',
            statusSuggestion: 'This should automatically have a good default setting. Reach out to our Steamship support.'
          });
        }
        if (!_IS_LOCAL(base)) {
          // Rewrite the base to be https://user.base
          var parts = base.split('//');
          if (parts.length < 2) {
            throw new SteamshipError({
              statusCode: 'EndpointInvalid',
              statusMessage: 'You package base did not appear to begin with a valid HTTP or HTTPS protocol.',
              statusSuggestion: "Make sure you've provided an app base such as https://steamship.run, with the protocol."
            });
          }
          // Now we pre-pend the app-base to the first part!
          parts[1] = (postConfig == null ? void 0 : postConfig.packageOwner) + "." + parts[1];
          base = parts.join('//');
        }
      }

      // Guard against a double // after the domain

      if (base && base[base.length - 1] == '/') {
        base = base.slice(0, base.length - 1);
      }
      if (operation && operation[0] == '/') {
        operation = operation.slice(1);
      }
      return base + "/" + operation;
    }
  }, {
    key: "post",
    value: function () {
      var _post = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(operation, payload, config, overrideConfig) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.call('POST', operation, payload, config, overrideConfig));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function post(_x5, _x6, _x7, _x8) {
        return _post.apply(this, arguments);
      }
      return post;
    }()
  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(operation, payload, config) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", this.call('GET', operation, payload, config));
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function get(_x9, _x10, _x11) {
        return _get.apply(this, arguments);
      }
      return get;
    }()
  }, {
    key: "_makeError",
    value: function () {
      var _makeError2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref) {
        var error, response, task, j;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              error = _ref.error, response = _ref.response, task = _ref.task;
              if (!error) {
                _context5.next = 5;
                break;
              }
              return _context5.abrupt("return", error);
            case 5:
              if (!response) {
                _context5.next = 20;
                break;
              }
              _context5.prev = 6;
              _context5.next = 9;
              return response.data;
            case 9:
              j = _context5.sent;
              if (!j.status) {
                _context5.next = 12;
                break;
              }
              return _context5.abrupt("return", new SteamshipError({
                statusMessage: j.status.statusMessage,
                statusCode: j.status.statusCode,
                statusSuggestion: j.status.statusSuggestion
              }));
            case 12:
              _context5.next = 17;
              break;
            case 14:
              _context5.prev = 14;
              _context5.t0 = _context5["catch"](6);
              return _context5.abrupt("return", new SteamshipError({
                statusMessage: 'Bad response from server'
              }));
            case 17:
              return _context5.abrupt("return", new SteamshipError({
                statusMessage: 'Bad response from server'
              }));
            case 20:
              if (!task) {
                _context5.next = 22;
                break;
              }
              return _context5.abrupt("return", new SteamshipError({
                statusMessage: task.statusMessage,
                statusCode: task.statusCode,
                statusSuggestion: task.statusSuggestion
              }));
            case 22:
              return _context5.abrupt("return", new SteamshipError({
                statusMessage: 'Bad response'
              }));
            case 23:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[6, 14]]);
      }));
      function _makeError(_x12) {
        return _makeError2.apply(this, arguments);
      }
      return _makeError;
    }()
  }, {
    key: "_makeResponse",
    value: function () {
      var _makeResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var _json, _json2;
        var response, rawResponse, objectConstructor, responsePath, err, json, taskParams, task, _task;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              response = _ref2.response, rawResponse = _ref2.rawResponse, objectConstructor = _ref2.objectConstructor, responsePath = _ref2.responsePath;
              if (response) {
                _context6.next = 3;
                break;
              }
              throw new SteamshipError({
                statusMessage: 'No response.'
              });
            case 3:
              if (!(response.status != 200)) {
                _context6.next = 8;
                break;
              }
              _context6.next = 6;
              return this._makeError({
                response: response
              });
            case 6:
              err = _context6.sent;
              throw err;
            case 8:
              if (!rawResponse) {
                _context6.next = 10;
                break;
              }
              return _context6.abrupt("return", response);
            case 10:
              _context6.prev = 10;
              json = response.data; // Axios
              // json = JSON.parse((response as any).body); // Got
              // json = await response.json(); // for the fetch style // Fetch
              _context6.next = 19;
              break;
            case 14:
              _context6.prev = 14;
              _context6.t0 = _context6["catch"](10);
              _context6.next = 18;
              return this._makeError({
                error: _context6.t0
              });
            case 18:
              throw _context6.sent;
            case 19:
              if (!(typeof json == 'undefined' || json == null)) {
                _context6.next = 21;
                break;
              }
              throw new SteamshipError({
                statusMessage: 'Empty response.'
              });
            case 21:
              taskParams = (_json = json) == null ? void 0 : _json.status;
              if (!(typeof (taskParams == null ? void 0 : taskParams.state) != 'undefined')) {
                _context6.next = 30;
                break;
              }
              task = new Task(this, _extends({}, taskParams, {
                responsePath: responsePath,
                rawResponse: rawResponse,
                objectConstructor: objectConstructor
              }));
              if (!(((_task = task) == null ? void 0 : _task.state) == TaskState.failed)) {
                _context6.next = 28;
                break;
              }
              _context6.next = 27;
              return this._makeError({
                task: task
              });
            case 27:
              throw _context6.sent;
            case 28:
              _context6.next = 31;
              break;
            case 30:
              task = new Task(this, {
                responsePath: responsePath,
                rawResponse: rawResponse,
                objectConstructor: objectConstructor
              });
            case 31:
              task.setData((_json2 = json) == null ? void 0 : _json2.data);
              return _context6.abrupt("return", task);
            case 33:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[10, 14]]);
      }));
      function _makeResponse(_x13) {
        return _makeResponse2.apply(this, arguments);
      }
      return _makeResponse;
    }()
  }, {
    key: "call",
    value: function () {
      var _call = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(verb, operation, payload, config, overrideConfig) {
        var baseConfig, url, headers, reqConfig, finalPayload, contentType, FormDataNode, formData, pp, _i2, _Object$keys, _key2, value, _formData, _pp, _i3, _Object$keys2, _key3, _value, resp;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.t0 = overrideConfig;
              if (_context7.t0) {
                _context7.next = 5;
                break;
              }
              _context7.next = 4;
              return this.config;
            case 4:
              _context7.t0 = _context7.sent;
            case 5:
              baseConfig = _context7.t0;
              if (baseConfig.apiKey) {
                _context7.next = 8;
                break;
              }
              throw new SteamshipError({
                statusCode: 'Authentication',
                statusMessage: 'API Key not found.',
                statusSuggestion: 'Please see docs.steamship.com for a variety of ways to set your API key.'
              });
            case 8:
              url = this._url(baseConfig, config, operation);
              headers = this._headers(baseConfig, config);
              reqConfig = {
                headers: headers,
                maxContentLength: MAX_BODY_LENGTH,
                maxBodyLength: MAX_BODY_LENGTH
              };
              finalPayload = undefined;
              if (!(verb == 'POST' && config != null && config.file)) {
                _context7.next = 35;
                break;
              }
              contentType = undefined;
              if (typeof config.file != 'string') {
                contentType = 'binary/octet-stream';
              }

              // Important so proper boundary can be set;
              delete reqConfig.headers['Content-Type'];
              if (!isNode()) {
                _context7.next = 28;
                break;
              }
              _context7.next = 19;
              return import('form-data');
            case 19:
              FormDataNode = _context7.sent;
              formData = new FormDataNode["default"]();
              formData.append('file', Buffer.from(config.file), {
                filename: config == null ? void 0 : config.filename,
                contentType: contentType
              });
              pp = payload;
              for (_i2 = 0, _Object$keys = Object.keys(pp); _i2 < _Object$keys.length; _i2++) {
                _key2 = _Object$keys[_i2];
                value = pp[_key2];
                addMultiparts(formData, _key2, value);
              }
              finalPayload = formData;

              // This only needs to happen on Node.
              // And the .getHeaders method is unavilabile in the browser.
              // NOTE: This is untested in the unit tests; it will show up as a failure in the browser.
              // TODO: We need to start running tests inside a browser runtime too.
              reqConfig.headers = _extends({}, reqConfig.headers, formData.getHeaders());
              _context7.next = 33;
              break;
            case 28:
              _formData = new FormData();
              /*
               * The config.file as any cast below is because FormData does not support Buffer.
               * In general, file as a Buffer should only be done from within the NodeJS environment,
               * not from within the browser. In the browser, Blob should be used instead.
               *
               * TODO: Figure out if there's a way to strongly type (or at least runtime check) this
               * so that we get back intelligent errors that are environment-dependent.
               */
              _formData.append('file', config.file, config == null ? void 0 : config.filename);
              _pp = payload;
              for (_i3 = 0, _Object$keys2 = Object.keys(_pp); _i3 < _Object$keys2.length; _i3++) {
                _key3 = _Object$keys2[_i3];
                _value = _pp[_key3];
                addMultiparts(_formData, _key3, _value);
              }
              finalPayload = _formData;
            case 33:
              _context7.next = 36;
              break;
            case 35:
              if (typeof payload == 'object') {
                finalPayload = JSON.stringify(payload);
              } else {
                finalPayload = payload;
              }
            case 36:
              _context7.prev = 36;
              if (!(verb == 'POST')) {
                _context7.next = 43;
                break;
              }
              _context7.next = 40;
              return doFetch(url, {
                method: verb,
                body: finalPayload,
                headers: reqConfig.headers
              });
            case 40:
              resp = _context7.sent;
              _context7.next = 51;
              break;
            case 43:
              if (!(verb == 'GET')) {
                _context7.next = 50;
                break;
              }
              // TODO: Incorporate params into the query string
              if (payload) {
                url = url + '?' + new URLSearchParams(payload);
              }
              _context7.next = 47;
              return doFetch(url, {
                method: verb,
                headers: reqConfig.headers
              });
            case 47:
              resp = _context7.sent;
              _context7.next = 51;
              break;
            case 50:
              throw new SteamshipError({
                statusMessage: "Unsupported HTTP Verb: " + verb
              });
            case 51:
              _context7.next = 56;
              break;
            case 53:
              _context7.prev = 53;
              _context7.t1 = _context7["catch"](36);
              throw this._makeError({
                error: _context7.t1
              });
            case 56:
              return _context7.abrupt("return", this._makeResponse({
                response: resp,
                rawResponse: config == null ? void 0 : config.rawResponse,
                objectConstructor: config == null ? void 0 : config.expect,
                responsePath: config == null ? void 0 : config.responsePath
              }));
            case 57:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[36, 53]]);
      }));
      function call(_x14, _x15, _x16, _x17, _x18) {
        return _call.apply(this, arguments);
      }
      return call;
    }()
  }]);
  return ApiBase;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJheGlvcyIsImdldExvZ2dlciIsImxvYWRDb25maWd1cmF0aW9uIiwiU3RlYW1zaGlwRXJyb3IiLCJUYXNrIiwiVGFza1N0YXRlIiwiaXNOb2RlIiwiZG9GZXRjaCIsInVybCIsIm9wdHMiLCJoZWFkZXJzIiwiZGF0YSIsImJvZHkiLCJtZXRob2QiLCJsb2ciLCJNQVhfQk9EWV9MRU5HVEgiLCJfSVNfTE9DQUwiLCJiYXNlIiwicyIsImluY2x1ZGVzIiwiYWRkTXVsdGlwYXJ0cyIsImZvcm1EYXRhIiwicGF0aCIsInZhbHVlIiwidHlwZSIsImFwcGVuZCIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJzdWJWYWx1ZSIsImluZGV4Iiwia2V5IiwiQXBpQmFzZSIsInBhcmFtcyIsImNvbmZpZyIsInRoZW4iLCJhcGlLZXkiLCJfc3dpdGNoQ29uZmlnV29ya3NwYWNlIiwid29ya3NwYWNlSGFuZGxlIiwid29ya3NwYWNlIiwiZmFpbElmV29ya3NwYWNlRXhpc3RzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbmZvIiwid29ya3NwYWNlSWQiLCJ1bmRlZmluZWQiLCJwIiwib2xkQ29uZmlnIiwiYWN0aXZlQ29uZmlnIiwicG9zdCIsImhhbmRsZSIsImZldGNoSWZFeGlzdHMiLCJyZXNwb25zZVBhdGgiLCJvdXRwdXQiLCJzdGF0dXNNZXNzYWdlIiwicmV0dXJuSWQiLCJpZCIsInJldHVybkhhbmRsZSIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInBvc3RDb25maWciLCJyZXQiLCJBdXRob3JpemF0aW9uIiwiaXNQYWNrYWdlQ2FsbCIsInBhY2thZ2VPd25lciIsInBhY2thZ2VJZCIsInBhY2thZ2VJbnN0YW5jZUlkIiwiYXNCYWNrZ3JvdW5kVGFzayIsImJhc2VDb25maWciLCJvcGVyYXRpb24iLCJhcGlCYXNlIiwic3RhdHVzQ29kZSIsInN0YXR1c1N1Z2dlc3Rpb24iLCJhcHBCYXNlIiwicGFydHMiLCJzcGxpdCIsImxlbmd0aCIsImpvaW4iLCJzbGljZSIsInBheWxvYWQiLCJvdmVycmlkZUNvbmZpZyIsImNhbGwiLCJyZXNwb25zZSIsInRhc2siLCJqIiwic3RhdHVzIiwicmF3UmVzcG9uc2UiLCJvYmplY3RDb25zdHJ1Y3RvciIsIl9tYWtlRXJyb3IiLCJlcnIiLCJqc29uIiwidGFza1BhcmFtcyIsInN0YXRlIiwiZmFpbGVkIiwic2V0RGF0YSIsInZlcmIiLCJfdXJsIiwiX2hlYWRlcnMiLCJyZXFDb25maWciLCJtYXhDb250ZW50TGVuZ3RoIiwibWF4Qm9keUxlbmd0aCIsImZpbmFsUGF5bG9hZCIsImZpbGUiLCJjb250ZW50VHlwZSIsIkZvcm1EYXRhTm9kZSIsIkJ1ZmZlciIsImZyb20iLCJmaWxlbmFtZSIsInBwIiwiT2JqZWN0Iiwia2V5cyIsImdldEhlYWRlcnMiLCJGb3JtRGF0YSIsInJlc3AiLCJVUkxTZWFyY2hQYXJhbXMiLCJfbWFrZVJlc3BvbnNlIiwiZXhwZWN0Il0sInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9hcGlfYmFzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MsIHsgQXhpb3NSZXNwb25zZSB9IGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ3RzbG9nJztcblxuaW1wb3J0IGdldExvZ2dlciBmcm9tICcuL2xvZy5qcyc7XG5pbXBvcnQge1xuICBJQXBpQmFzZSxcbiAgSVRhc2ssXG4gIFBvc3RDb25maWcsXG4gIFN3aXRjaFdvcmtzcGFjZVBhcmFtcyxcbiAgVmVyYixcbn0gZnJvbSAnLi9zaGFyZWQvQmFzZUludGVyZmFjZXMuanMnO1xuaW1wb3J0IHtcbiAgQ29uZmlndXJhdGlvbixcbiAgTG9hZENvbmZpZ1BhcmFtcyxcbiAgbG9hZENvbmZpZ3VyYXRpb24sXG59IGZyb20gJy4vc2hhcmVkL0NvbmZpZ3VyYXRpb24uanMnO1xuaW1wb3J0IHsgU3RlYW1zaGlwRXJyb3IgfSBmcm9tICcuL3N0ZWFtc2hpcF9lcnJvci5qcyc7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi90YXNrLmpzJztcbmltcG9ydCB7IFRhc2tQYXJhbXMsIFRhc2tTdGF0ZSB9IGZyb20gJy4vdHlwZXMvYmFzZS5qcyc7XG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuYXN5bmMgZnVuY3Rpb24gZG9GZXRjaCh1cmw6IGFueSwgb3B0czogYW55KTogUHJvbWlzZTxBeGlvc1Jlc3BvbnNlPiB7XG4gIHJldHVybiBheGlvcyh7XG4gICAgdXJsLFxuICAgIGhlYWRlcnM6IG9wdHMuaGVhZGVycyxcbiAgICBkYXRhOiBvcHRzLmJvZHksXG4gICAgbWV0aG9kOiBvcHRzLm1ldGhvZCxcbiAgfSk7XG59XG5cbi8vIGFzeW5jIGZ1bmN0aW9uIGRvRmV0Y2godXJsOiBhbnksIG9wdHM6IGFueSk6IFByb21pc2U8QXhpb3NSZXNwb25zZT4ge1xuLy8gICByZXR1cm4gbmV3IFByb21pc2U8QXhpb3NSZXNwb25zZT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuLy8gICAgIGF4aW9zKHtcbi8vICAgICAgIHVybCxcbi8vICAgICAgIGhlYWRlcnM6IG9wdHMuaGVhZGVycyxcbi8vICAgICAgIGRhdGE6IG9wdHMuYm9keSxcbi8vICAgICAgIG1ldGhvZDogb3B0cy5tZXRob2QsXG4vLyAgICAgfSkudGhlbihyZXNvbHZlKVxuLy8gICAgICAgLmNhdGNoKFxuLy8gICAgICAgICAoZXJyKSA9PiB7XG4vLyAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbi8vICAgICAgICAgICByZWplY3QoZXJyKTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgKVxuLy8gICB9KVxuLy8gfVxuXG5jb25zdCBsb2c6IExvZ2dlciA9IGdldExvZ2dlcignU3RlYW1zaGlwOkFwaUJhc2UnKTtcblxuY29uc3QgTUFYX0JPRFlfTEVOR1RIID0gMTAwMDAwICogMTAwMDtcblxuY29uc3QgX0lTX0xPQ0FMID0gKGJhc2U6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICBmb3IgKGNvbnN0IHMgb2YgW1xuICAgICdsb2NhbGhvc3QnLFxuICAgICcxMjcuMC4wLjEnLFxuICAgICcwOjA6MDowJyxcbiAgICAnOjMwMDAnLFxuICAgICdzdGVhbXNoaXAubG9jYWwnLFxuICAgICdob3N0LmRvY2tlci5pbnRlcm5hbCcsXG4gICAgJy90ZXN0OicsXG4gICAgJy8vYXBwLnN0YWdpbmcuc3RlYW1zaGlwLmNvbScsIC8vIEZvciB0aGUgZGVtbyB1c2VyIHByb3h5IHRyaWNrIC0gdGhpcyBpcyB0aGUgd2Vic2l0ZSBwcm94eVxuICAgICcvL2FwcC5zdGVhbXNoaXAuY29tJywgLy8gRm9yIHRoZSBkZW1vIHVzZXIgcHJveHkgdHJpY2sgLSB0aGlzIGlzIHRoZSB3ZWJzaXRlIHByb3h5XG4gIF0pIHtcbiAgICBpZiAoYmFzZS5pbmNsdWRlcyhzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qIFNob3VsZCBiZSBhIEZvcm1EYXRhIG9iamVjdCAqL1xuZnVuY3Rpb24gYWRkTXVsdGlwYXJ0cyhmb3JtRGF0YTogYW55LCBwYXRoOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgLyogRGVjb2RlIGFueSBvYmplY3QgaW50byBhIHNlcmllcyBvZiBIVFRQIE11bHRpLXBhcnQgc2VnbWVudHMgdGhhdCBWYXBvciB3aWxsIGNvbnN1bWUuXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL3ZhcG9yL211bHRpcGFydC1raXRcblxuICAgIFdoZW4gc2VuZGluZyBhIEpTT04gb2JqZWN0IGluIGEgTXVsdGlQYXJ0IHJlcXVlc3QsIFZhcG9yIHdpc2hlcyB0byBzZWUgbXVsdGkgcGFydCBzZWdtZW50cyBhcyBmb2xsb3dzOlxuICAgIHNpbmdsZV9rZXlcbiAgICBhcnJheV9rZXlbaWR4XVxuICAgIG9ial9rZXlbcHJvcF1cblxuICAgIFNvIGEgRmlsZSB3aXRoIGEgbGlzdCBvZiBvbmUgdGFnIHdpdGgga2luZD1Gb28gd291bGQgYmUgdHJhbnNtaXR0ZWQgYXMgc2V0dGluZyB0aGUgcGFydDpcbiAgICBbdGFnc11bMF1ba2luZF1cbiAgKi9cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHwgdHlwZSA9PSAnbnVtYmVyJykge1xuICAgIGZvcm1EYXRhLmFwcGVuZChwYXRoLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKChzdWJWYWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGFkZE11bHRpcGFydHMoZm9ybURhdGEsIGAke3BhdGh9WyR7aW5kZXh9XWAsIHN1YlZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgYWRkTXVsdGlwYXJ0cyhmb3JtRGF0YSwgYCR7cGF0aH1bJHtrZXl9XWAsIHZhbHVlW2tleV0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN3aXRjaENvbmZpZ1dvcmtzcGFjZVBhcmFtcyB7XG4gIHdvcmtzcGFjZUhhbmRsZT86IHN0cmluZztcbiAgZmFpbElmV29ya3NwYWNlRXhpc3RzPzogYm9vbGVhbjtcbiAgY29uZmlnOiBDb25maWd1cmF0aW9uO1xufVxuXG5leHBvcnQgY2xhc3MgQXBpQmFzZSBpbXBsZW1lbnRzIElBcGlCYXNlIHtcbiAgY29uZmlnOiBQcm9taXNlPENvbmZpZ3VyYXRpb24+IHwgQ29uZmlndXJhdGlvbjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocGFyYW1zPzogTG9hZENvbmZpZ1BhcmFtcykge1xuICAgIHRoaXMuY29uZmlnID0gbG9hZENvbmZpZ3VyYXRpb24ocGFyYW1zKS50aGVuKChjb25maWcpID0+IHtcbiAgICAgIGlmIChjb25maWcuYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zd2l0Y2hDb25maWdXb3Jrc3BhY2Uoe1xuICAgICAgICAgIHdvcmtzcGFjZUhhbmRsZTogcGFyYW1zPy53b3Jrc3BhY2UsXG4gICAgICAgICAgZmFpbElmV29ya3NwYWNlRXhpc3RzOiBwYXJhbXM/LmZhaWxJZldvcmtzcGFjZUV4aXN0cyA9PT0gdHJ1ZSxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHN3aXRjaFdvcmtzcGFjZShwYXJhbXM/OiBTd2l0Y2hXb3Jrc3BhY2VQYXJhbXMpIHtcbiAgICBjb25zdCBjb25maWcgPSBhd2FpdCB0aGlzLl9zd2l0Y2hDb25maWdXb3Jrc3BhY2Uoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgY29uZmlnOiBhd2FpdCB0aGlzLmNvbmZpZyxcbiAgICB9KTtcbiAgICB0aGlzLmNvbmZpZyA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuICAgIGxvZy5pbmZvKFxuICAgICAgYFN3aXRjaGVkIHRvIHdvcmtzcGFjZSAke2NvbmZpZy53b3Jrc3BhY2VIYW5kbGV9LyR7Y29uZmlnLndvcmtzcGFjZUlkfWBcbiAgICApO1xuICB9XG5cbiAgLypcbiAgICBTd2l0Y2hlcyB0aGlzIGNsaWVudCB0byB0aGUgcmVxdWVzdGVkIHdvcmtzcGFjZSwgcG9zc2libHkgY3JlYXRpbmcgaXQuIElmIGFsbCBhcmd1bWVudHMgYXJlIE5vbmUsIHRoZSBjbGllbnRcbiAgICBhY3RpdmVseSBzd2l0Y2hlcyBpbnRvIHRoZSBkZWZhdWx0IHdvcmtzcGFjZS5cblxuICAgIC0gQVBJIGNhbGxzIGFyZSBwZXJmb3JtZWQgbWFudWFsbHkgdG8gbm90IHJlc3VsdCBpbiBjaXJjdWxhciBpbXBvcnRzLlxuICAgIC0gTm90ZSB0aGF0IHRoZSBkZWZhdWx0IHdvcmtzcGFjZSBpcyB0ZWNobmljYWxseSBub3QgbmVjZXNzYXJ5IGZvciBBUEkgdXNhZ2U7IGl0IHdpbGwgYmUgYXNzdW1lZCBieSB0aGUgRW5naW5lXG4gICAgICBpbiB0aGUgYWJzZW5zZSBvZiBhIFdvcmtzcGFjZSBJRCBvciBIYW5kbGUgYmVpbmcgbWFudWFsbHkgc3BlY2lmaWVkIGluIHJlcXVlc3QgaGVhZGVycy5cbiAgICovXG4gIGFzeW5jIF9zd2l0Y2hDb25maWdXb3Jrc3BhY2UoXG4gICAgcGFyYW1zOiBTd2l0Y2hDb25maWdXb3Jrc3BhY2VQYXJhbXNcbiAgKTogUHJvbWlzZTxDb25maWd1cmF0aW9uPiB7XG4gICAgbGV0IHdvcmtzcGFjZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHA6IFN3aXRjaFdvcmtzcGFjZVBhcmFtcyA9IHsgLi4ucGFyYW1zIH07XG5cbiAgICBpZiAoIXAud29ya3NwYWNlSGFuZGxlKSB7XG4gICAgICBwLndvcmtzcGFjZUhhbmRsZSA9ICdkZWZhdWx0JztcbiAgICB9XG5cbiAgICBpZiAocC5mYWlsSWZXb3Jrc3BhY2VFeGlzdHMpIHtcbiAgICAgIGxvZy5pbmZvKGBDcmVhdGluZyB3b3Jrc3BhY2Ugd2l0aCBoYW5kbGU6ICR7cC53b3Jrc3BhY2VIYW5kbGV9LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuaW5mbyhcbiAgICAgICAgYENyZWF0aW5nL0ZldGNoaW5nIHdvcmtzcGFjZSB3aXRoIGhhbmRsZTogJHtwLndvcmtzcGFjZUhhbmRsZX0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBaZXJvIG91dCB0aGUgd29ya3NwYWNlX2hhbmRsZSBvbiB0aGUgY29uZmlnIGJsb2NrIGluIGNhc2Ugd2UncmUgYmVpbmcgaW52b2tlZCBmcm9tXG4gICAgLy8gYGluaXRgIChvdGhlcndpc2Ugd2UnbGwgYXR0ZW1wdCB0byBjcmVhdGUgdGhlIHNhcGNlIElOIHRoYXQgbm9uZXhpc3RhbnQgd29ya3NwYWNlKVxuICAgIGNvbnN0IG9sZENvbmZpZyA9IHBhcmFtcy5jb25maWc7XG5cbiAgICBjb25zdCBhY3RpdmVDb25maWcgPSB7XG4gICAgICAuLi5vbGRDb25maWcsXG4gICAgICB3b3Jrc3BhY2VIYW5kbGU6IHVuZGVmaW5lZCxcbiAgICAgIHdvcmtzcGFjZUlkOiB1bmRlZmluZWQsXG4gICAgfTtcblxuICAgIHdvcmtzcGFjZSA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgICd3b3Jrc3BhY2UvY3JlYXRlJyxcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlOiBwLndvcmtzcGFjZUhhbmRsZSxcbiAgICAgICAgZmV0Y2hJZkV4aXN0czogIShwLmZhaWxJZldvcmtzcGFjZUV4aXN0cyA9PT0gdHJ1ZSksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZXNwb25zZVBhdGg6ICd3b3Jrc3BhY2UnLFxuICAgICAgfSxcbiAgICAgIGFjdGl2ZUNvbmZpZ1xuICAgICk7XG5cbiAgICBpZiAoIXdvcmtzcGFjZSB8fCAhd29ya3NwYWNlLm91dHB1dCkge1xuICAgICAgdGhyb3cgbmV3IFN0ZWFtc2hpcEVycm9yKHtcbiAgICAgICAgc3RhdHVzTWVzc2FnZTpcbiAgICAgICAgICAnV2FzIHVuYWJsZSB0byBzd2l0Y2ggdG8gbmV3IHdvcmtzcGFjZTogc2VydmVyIHJldHVybmVkIGVtcHR5IFdvcmtzcGFjZS4nLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmV0dXJuSWQ6IHN0cmluZyA9IHdvcmtzcGFjZS5vdXRwdXQuaWQ7XG4gICAgY29uc3QgcmV0dXJuSGFuZGxlOiBzdHJpbmcgPSB3b3Jrc3BhY2Uub3V0cHV0LmhhbmRsZTtcblxuICAgIGlmICghcmV0dXJuSGFuZGxlIHx8ICFyZXR1cm5JZCkge1xuICAgICAgbG9nLmVycm9yKHdvcmtzcGFjZSk7XG4gICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICBzdGF0dXNNZXNzYWdlOiBgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB3b3Jrc3BhY2VcbiAgICAgICAgKX0gVW5hYmxlIHRvIHN3aXRjaCB0byB3b3Jrc3BhY2UgJHtcbiAgICAgICAgICBwLndvcmtzcGFjZUhhbmRsZVxuICAgICAgICB9IHdpdGggZmFpbElmV29ya3NwYWNlRXhpc3RzICR7XG4gICAgICAgICAgcC5mYWlsSWZXb3Jrc3BhY2VFeGlzdHNcbiAgICAgICAgfTogc2VydmVyIHJldHVybmVkIGVtcHR5IElEIGFuZCBIYW5kbGUuYCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIHNldCB0aGUgbmV3IHdvcmtzcGFjZVxuICAgIHJldHVybiB7XG4gICAgICAuLi5vbGRDb25maWcsXG4gICAgICB3b3Jrc3BhY2VIYW5kbGU6IHJldHVybkhhbmRsZSxcbiAgICAgIHdvcmtzcGFjZUlkOiByZXR1cm5JZCxcbiAgICB9O1xuICB9XG5cbiAgX2hlYWRlcnM8VD4oXG4gICAgY29uZmlnOiBDb25maWd1cmF0aW9uLFxuICAgIHBvc3RDb25maWc/OiBQb3N0Q29uZmlnPFQ+XG4gICk6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9IHtcbiAgICBjb25zdCByZXQ6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb25maWcuYXBpS2V5fWAsXG4gICAgfTtcblxuICAgIGlmIChwb3N0Q29uZmlnPy53b3Jrc3BhY2VJZCkge1xuICAgICAgcmV0WydYLVdvcmtzcGFjZS1JZCddID0gcG9zdENvbmZpZz8ud29ya3NwYWNlSWQ7XG4gICAgfSBlbHNlIGlmIChjb25maWcud29ya3NwYWNlSWQpIHtcbiAgICAgIHJldFsnWC1Xb3Jrc3BhY2UtSWQnXSA9IGNvbmZpZy53b3Jrc3BhY2VJZDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy53b3Jrc3BhY2VIYW5kbGUpIHtcbiAgICAgIHJldFsnWC1Xb3Jrc3BhY2UtSGFuZGxlJ10gPSBjb25maWcud29ya3NwYWNlSGFuZGxlO1xuICAgIH1cblxuICAgIGlmIChwb3N0Q29uZmlnPy5pc1BhY2thZ2VDYWxsID09PSB0cnVlKSB7XG4gICAgICBpZiAocG9zdENvbmZpZz8ucGFja2FnZU93bmVyKSB7XG4gICAgICAgIHJldFsnWC1QYWNrYWdlLU93bmVyLUhhbmRsZSddID0gcG9zdENvbmZpZy5wYWNrYWdlT3duZXI7XG4gICAgICB9XG4gICAgICBpZiAocG9zdENvbmZpZz8ucGFja2FnZUlkKSB7XG4gICAgICAgIHJldFsnWC1QYWNrYWdlLUlkJ10gPSBwb3N0Q29uZmlnLnBhY2thZ2VJZDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3N0Q29uZmlnPy5wYWNrYWdlSW5zdGFuY2VJZCkge1xuICAgICAgICByZXRbJ1gtUGFja2FnZS1JbnN0YW5jZS1JZCddID0gcG9zdENvbmZpZy5wYWNrYWdlSW5zdGFuY2VJZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zdENvbmZpZz8uYXNCYWNrZ3JvdW5kVGFzayA9PT0gdHJ1ZSkge1xuICAgICAgLy8gV2lsbCByZXN1bHQgaW4gdGhlIGVuZ2luZSBwZXJzaXN0aW5nIHRoZSBpbmJvdW5kIEhUVFAgcmVxdWVzdCBhcyBhIFRhc2sgZm9yIGRlZmVycmVkXG4gICAgICAvLyBleGVjdXRpb24uIFRoZSBjbGllbnQgd2lsbCByZWNlaXZlIHRhc2sgaW5mb3JtYXRpb24gYmFjayBpbnN0ZWFkIG9mIHRoZSBzeW5jaHJvbm91cyBBUEkgcmVzcG9uc2UuXG4gICAgICAvLyBUaGF0IHRhc2sgY2FuIGJlIHBvbGxlZCBmb3IgZXZlbnR1YWwgY29tcGxldGlvbi5cbiAgICAgIHJldFsnWC1UYXNrLUJhY2tncm91bmQnXSA9ICd0cnVlJztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIF91cmw8VD4oXG4gICAgYmFzZUNvbmZpZzogQ29uZmlndXJhdGlvbixcbiAgICBwb3N0Q29uZmlnPzogUG9zdENvbmZpZzxUPixcbiAgICBvcGVyYXRpb24/OiBzdHJpbmdcbiAgKTogc3RyaW5nIHtcbiAgICBsZXQgYmFzZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gJyc7XG5cbiAgICBpZiAoIShwb3N0Q29uZmlnPy5pc1BhY2thZ2VDYWxsID09PSB0cnVlKSkge1xuICAgICAgLy8gSXQncyBhbiBBUEkgY2FsbFxuICAgICAgYmFzZSA9IHBvc3RDb25maWc/LmFwaUJhc2UgfHwgYmFzZUNvbmZpZy5hcGlCYXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJdCdzIGEgcGFja2FnZSBjYWxsXG4gICAgICBpZiAoIXBvc3RDb25maWc/LnBhY2thZ2VPd25lcikge1xuICAgICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICAgIHN0YXR1c0NvZGU6ICdVc2VyTWlzc2luZycsXG4gICAgICAgICAgc3RhdHVzTWVzc2FnZTpcbiAgICAgICAgICAgIFwiQ2FuIG5vdCBpbnZva2UgYW4gcGFja2FnZSBlbmRwb2ludCB3aXRob3V0IHRoZSBwYWNrYWdlIG93bmVyJ3MgdXNlciBoYW5kbGUuXCIsXG4gICAgICAgICAgc3RhdHVzU3VnZ2VzdGlvbjpcbiAgICAgICAgICAgICdQcm92aWRlIHRoZSBwYWNrYWdlT3duZXIgb3B0aW9uLCBvciBpbml0aWFsaXplIHlvdXIgcGFja2FnZSB3aXRoIGEgbG9va3VwLicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBiYXNlID0gcG9zdENvbmZpZz8uYXBwQmFzZSB8fCBiYXNlQ29uZmlnLmFwcEJhc2U7XG5cbiAgICAgIGlmICghYmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICAgIHN0YXR1c0NvZGU6ICdFbmRwb2ludE1pc3NpbmcnLFxuICAgICAgICAgIHN0YXR1c01lc3NhZ2U6XG4gICAgICAgICAgICAnQ2FuIG5vdCBpbnZva2UgYW4gcGFja2FnZSBlbmRwb2ludCB3aXRob3V0IHRoZSBBcHAgQmFzZSB2YXJpYWJsZSBzZXQuJyxcbiAgICAgICAgICBzdGF0dXNTdWdnZXN0aW9uOlxuICAgICAgICAgICAgJ1RoaXMgc2hvdWxkIGF1dG9tYXRpY2FsbHkgaGF2ZSBhIGdvb2QgZGVmYXVsdCBzZXR0aW5nLiBSZWFjaCBvdXQgdG8gb3VyIFN0ZWFtc2hpcCBzdXBwb3J0LicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9JU19MT0NBTChiYXNlKSkge1xuICAgICAgICAvLyBSZXdyaXRlIHRoZSBiYXNlIHRvIGJlIGh0dHBzOi8vdXNlci5iYXNlXG4gICAgICAgIGNvbnN0IHBhcnRzID0gYmFzZS5zcGxpdCgnLy8nKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogJ0VuZHBvaW50SW52YWxpZCcsXG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlOlxuICAgICAgICAgICAgICAnWW91IHBhY2thZ2UgYmFzZSBkaWQgbm90IGFwcGVhciB0byBiZWdpbiB3aXRoIGEgdmFsaWQgSFRUUCBvciBIVFRQUyBwcm90b2NvbC4nLFxuICAgICAgICAgICAgc3RhdHVzU3VnZ2VzdGlvbjpcbiAgICAgICAgICAgICAgXCJNYWtlIHN1cmUgeW91J3ZlIHByb3ZpZGVkIGFuIGFwcCBiYXNlIHN1Y2ggYXMgaHR0cHM6Ly9zdGVhbXNoaXAucnVuLCB3aXRoIHRoZSBwcm90b2NvbC5cIixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgd2UgcHJlLXBlbmQgdGhlIGFwcC1iYXNlIHRvIHRoZSBmaXJzdCBwYXJ0IVxuICAgICAgICBwYXJ0c1sxXSA9IGAke3Bvc3RDb25maWc/LnBhY2thZ2VPd25lcn0uJHtwYXJ0c1sxXX1gO1xuICAgICAgICBiYXNlID0gcGFydHMuam9pbignLy8nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHdWFyZCBhZ2FpbnN0IGEgZG91YmxlIC8vIGFmdGVyIHRoZSBkb21haW5cblxuICAgIGlmIChiYXNlICYmIGJhc2VbYmFzZS5sZW5ndGggLSAxXSA9PSAnLycpIHtcbiAgICAgIGJhc2UgPSBiYXNlLnNsaWNlKDAsIGJhc2UubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGlmIChvcGVyYXRpb24gJiYgb3BlcmF0aW9uWzBdID09ICcvJykge1xuICAgICAgb3BlcmF0aW9uID0gb3BlcmF0aW9uLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7YmFzZX0vJHtvcGVyYXRpb259YDtcbiAgfVxuXG4gIGFzeW5jIHBvc3Q8VD4oXG4gICAgb3BlcmF0aW9uOiBzdHJpbmcsXG4gICAgcGF5bG9hZDogdW5rbm93bixcbiAgICBjb25maWc/OiBQb3N0Q29uZmlnPFQ+LFxuICAgIG92ZXJyaWRlQ29uZmlnPzogQ29uZmlndXJhdGlvblxuICApOiBQcm9taXNlPEF4aW9zUmVzcG9uc2UgfCBJVGFzazxUPj4ge1xuICAgIHJldHVybiB0aGlzLmNhbGwoJ1BPU1QnLCBvcGVyYXRpb24sIHBheWxvYWQsIGNvbmZpZywgb3ZlcnJpZGVDb25maWcpO1xuICB9XG5cbiAgYXN5bmMgZ2V0PFQ+KFxuICAgIG9wZXJhdGlvbjogc3RyaW5nLFxuICAgIHBheWxvYWQ6IHVua25vd24sXG4gICAgY29uZmlnPzogUG9zdENvbmZpZzxUPlxuICApOiBQcm9taXNlPEF4aW9zUmVzcG9uc2UgfCBJVGFzazxUPj4ge1xuICAgIHJldHVybiB0aGlzLmNhbGwoJ0dFVCcsIG9wZXJhdGlvbiwgcGF5bG9hZCwgY29uZmlnKTtcbiAgfVxuXG4gIGFzeW5jIF9tYWtlRXJyb3I8VD4oe1xuICAgIGVycm9yLFxuICAgIHJlc3BvbnNlLFxuICAgIHRhc2ssXG4gIH06IHtcbiAgICBlcnJvcj86IEVycm9yO1xuICAgIHJlc3BvbnNlPzogQXhpb3NSZXNwb25zZTtcbiAgICB0YXNrPzogSVRhc2s8VD47XG4gIH0pOiBQcm9taXNlPEVycm9yPiB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaiA9IGF3YWl0IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChqLnN0YXR1cykge1xuICAgICAgICAgIHJldHVybiBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogai5zdGF0dXMuc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IGouc3RhdHVzLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICBzdGF0dXNTdWdnZXN0aW9uOiBqLnN0YXR1cy5zdGF0dXNTdWdnZXN0aW9uLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVhbXNoaXBFcnJvcih7XG4gICAgICAgICAgc3RhdHVzTWVzc2FnZTogJ0JhZCByZXNwb25zZSBmcm9tIHNlcnZlcicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTdGVhbXNoaXBFcnJvcih7IHN0YXR1c01lc3NhZ2U6ICdCYWQgcmVzcG9uc2UgZnJvbSBzZXJ2ZXInIH0pO1xuICAgIH0gZWxzZSBpZiAodGFzaykge1xuICAgICAgcmV0dXJuIG5ldyBTdGVhbXNoaXBFcnJvcih7XG4gICAgICAgIHN0YXR1c01lc3NhZ2U6IHRhc2suc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgc3RhdHVzQ29kZTogdGFzay5zdGF0dXNDb2RlLFxuICAgICAgICBzdGF0dXNTdWdnZXN0aW9uOiB0YXNrLnN0YXR1c1N1Z2dlc3Rpb24sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdGVhbXNoaXBFcnJvcih7IHN0YXR1c01lc3NhZ2U6ICdCYWQgcmVzcG9uc2UnIH0pO1xuICB9XG5cbiAgYXN5bmMgX21ha2VSZXNwb25zZTxUPih7XG4gICAgcmVzcG9uc2UsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgb2JqZWN0Q29uc3RydWN0b3IsXG4gICAgcmVzcG9uc2VQYXRoLFxuICB9OiB7XG4gICAgcmVzcG9uc2U6IEF4aW9zUmVzcG9uc2U7XG4gICAgcmF3UmVzcG9uc2U/OiBib29sZWFuO1xuICAgIHJlc3BvbnNlUGF0aD86IHN0cmluZztcbiAgICBvYmplY3RDb25zdHJ1Y3Rvcj86IChjbGllbnQ6IGFueSwgZGF0YTogYW55KSA9PiBUO1xuICB9KTogUHJvbWlzZTxUYXNrPFQ+IHwgQXhpb3NSZXNwb25zZT4ge1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHRocm93IG5ldyBTdGVhbXNoaXBFcnJvcih7IHN0YXR1c01lc3NhZ2U6ICdObyByZXNwb25zZS4nIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT0gMjAwKSB7XG4gICAgICBjb25zdCBlcnIgPSBhd2FpdCB0aGlzLl9tYWtlRXJyb3IoeyByZXNwb25zZSB9KTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpZiAocmF3UmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBsZXQganNvbjogYW55O1xuICAgIHRyeSB7XG4gICAgICBqc29uID0gcmVzcG9uc2UuZGF0YTsgLy8gQXhpb3NcbiAgICAgIC8vIGpzb24gPSBKU09OLnBhcnNlKChyZXNwb25zZSBhcyBhbnkpLmJvZHkpOyAvLyBHb3RcbiAgICAgIC8vIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7IC8vIGZvciB0aGUgZmV0Y2ggc3R5bGUgLy8gRmV0Y2hcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICB0aHJvdyBhd2FpdCB0aGlzLl9tYWtlRXJyb3IoeyBlcnJvciB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGpzb24gPT0gJ3VuZGVmaW5lZCcgfHwganNvbiA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3IoeyBzdGF0dXNNZXNzYWdlOiAnRW1wdHkgcmVzcG9uc2UuJyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB0YXNrUGFyYW1zOiBUYXNrUGFyYW1zPFQ+ID0ganNvbj8uc3RhdHVzIGFzIFRhc2tQYXJhbXM8VD47XG4gICAgbGV0IHRhc2s6IFRhc2s8VD47XG5cbiAgICBpZiAodHlwZW9mIHRhc2tQYXJhbXM/LnN0YXRlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICB0YXNrID0gbmV3IFRhc2sodGhpcywge1xuICAgICAgICAuLi50YXNrUGFyYW1zLFxuICAgICAgICByZXNwb25zZVBhdGg6IHJlc3BvbnNlUGF0aCxcbiAgICAgICAgcmF3UmVzcG9uc2U6IHJhd1Jlc3BvbnNlLFxuICAgICAgICBvYmplY3RDb25zdHJ1Y3Rvcjogb2JqZWN0Q29uc3RydWN0b3IsXG4gICAgICB9KTtcbiAgICAgIGlmICh0YXNrPy5zdGF0ZSA9PSBUYXNrU3RhdGUuZmFpbGVkKSB7XG4gICAgICAgIHRocm93IGF3YWl0IHRoaXMuX21ha2VFcnJvcih7IHRhc2sgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhc2sgPSBuZXcgVGFzayh0aGlzLCB7XG4gICAgICAgIHJlc3BvbnNlUGF0aDogcmVzcG9uc2VQYXRoLFxuICAgICAgICByYXdSZXNwb25zZTogcmF3UmVzcG9uc2UsXG4gICAgICAgIG9iamVjdENvbnN0cnVjdG9yOiBvYmplY3RDb25zdHJ1Y3RvcixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRhc2suc2V0RGF0YShqc29uPy5kYXRhKTtcbiAgICByZXR1cm4gdGFzaztcbiAgfVxuXG4gIGFzeW5jIGNhbGw8VD4oXG4gICAgdmVyYjogVmVyYixcbiAgICBvcGVyYXRpb246IHN0cmluZyxcbiAgICBwYXlsb2FkOiB1bmtub3duLFxuICAgIGNvbmZpZz86IFBvc3RDb25maWc8VD4sXG4gICAgb3ZlcnJpZGVDb25maWc/OiBDb25maWd1cmF0aW9uXG4gICk6IFByb21pc2U8QXhpb3NSZXNwb25zZSB8IFRhc2s8VD4+IHtcbiAgICAvLyBUaGlzIG92ZXJyaWRlQ29uZmlnIHZhciBpcyBuZWNlc3NhcnkgZm9yIHRoZSBzd2l0Y2ggY29uZmlnIG9wZXJhdGlvbiBhdCBpbml0XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnIHx8IChhd2FpdCB0aGlzLmNvbmZpZyk7XG4gICAgaWYgKCFiYXNlQ29uZmlnLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IFN0ZWFtc2hpcEVycm9yKHtcbiAgICAgICAgc3RhdHVzQ29kZTogJ0F1dGhlbnRpY2F0aW9uJyxcbiAgICAgICAgc3RhdHVzTWVzc2FnZTogJ0FQSSBLZXkgbm90IGZvdW5kLicsXG4gICAgICAgIHN0YXR1c1N1Z2dlc3Rpb246XG4gICAgICAgICAgJ1BsZWFzZSBzZWUgZG9jcy5zdGVhbXNoaXAuY29tIGZvciBhIHZhcmlldHkgb2Ygd2F5cyB0byBzZXQgeW91ciBBUEkga2V5LicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgdXJsID0gdGhpcy5fdXJsKGJhc2VDb25maWcsIGNvbmZpZywgb3BlcmF0aW9uKTtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5faGVhZGVycyhiYXNlQ29uZmlnLCBjb25maWcpO1xuXG4gICAgY29uc3QgcmVxQ29uZmlnID0ge1xuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIG1heENvbnRlbnRMZW5ndGg6IE1BWF9CT0RZX0xFTkdUSCxcbiAgICAgIG1heEJvZHlMZW5ndGg6IE1BWF9CT0RZX0xFTkdUSCxcbiAgICB9O1xuXG4gICAgbGV0IGZpbmFsUGF5bG9hZDogdW5kZWZpbmVkIHwgdW5rbm93biB8IHsgW2tleTogc3RyaW5nXTogdW5kZWZpbmVkIH0gPVxuICAgICAgdW5kZWZpbmVkO1xuICAgIGlmICh2ZXJiID09ICdQT1NUJyAmJiBjb25maWc/LmZpbGUpIHtcbiAgICAgIGxldCBjb250ZW50VHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLmZpbGUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGVudFR5cGUgPSAnYmluYXJ5L29jdGV0LXN0cmVhbSc7XG4gICAgICB9XG5cbiAgICAgIC8vIEltcG9ydGFudCBzbyBwcm9wZXIgYm91bmRhcnkgY2FuIGJlIHNldDtcbiAgICAgIGRlbGV0ZSByZXFDb25maWcuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG5cbiAgICAgIGlmIChpc05vZGUoKSkge1xuICAgICAgICBjb25zdCBGb3JtRGF0YU5vZGUgPSBhd2FpdCBpbXBvcnQoJ2Zvcm0tZGF0YScpO1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YU5vZGUuZGVmYXVsdCgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBCdWZmZXIuZnJvbShjb25maWcuZmlsZSBhcyBhbnkpLCB7XG4gICAgICAgICAgZmlsZW5hbWU6IGNvbmZpZz8uZmlsZW5hbWUsXG4gICAgICAgICAgY29udGVudFR5cGU6IGNvbnRlbnRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHAgPSBwYXlsb2FkIGFzIHsgW2tleTogc3RyaW5nXTogdW5kZWZpbmVkIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBwKSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHBba2V5XTtcbiAgICAgICAgICBhZGRNdWx0aXBhcnRzKGZvcm1EYXRhLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbFBheWxvYWQgPSBmb3JtRGF0YTtcblxuICAgICAgICAvLyBUaGlzIG9ubHkgbmVlZHMgdG8gaGFwcGVuIG9uIE5vZGUuXG4gICAgICAgIC8vIEFuZCB0aGUgLmdldEhlYWRlcnMgbWV0aG9kIGlzIHVuYXZpbGFiaWxlIGluIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIHVudGVzdGVkIGluIHRoZSB1bml0IHRlc3RzOyBpdCB3aWxsIHNob3cgdXAgYXMgYSBmYWlsdXJlIGluIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHN0YXJ0IHJ1bm5pbmcgdGVzdHMgaW5zaWRlIGEgYnJvd3NlciBydW50aW1lIHRvby5cbiAgICAgICAgcmVxQ29uZmlnLmhlYWRlcnMgPSB7IC4uLnJlcUNvbmZpZy5oZWFkZXJzLCAuLi5mb3JtRGF0YS5nZXRIZWFkZXJzKCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBjb25maWcuZmlsZSBhcyBhbnkgY2FzdCBiZWxvdyBpcyBiZWNhdXNlIEZvcm1EYXRhIGRvZXMgbm90IHN1cHBvcnQgQnVmZmVyLlxuICAgICAgICAgKiBJbiBnZW5lcmFsLCBmaWxlIGFzIGEgQnVmZmVyIHNob3VsZCBvbmx5IGJlIGRvbmUgZnJvbSB3aXRoaW4gdGhlIE5vZGVKUyBlbnZpcm9ubWVudCxcbiAgICAgICAgICogbm90IGZyb20gd2l0aGluIHRoZSBicm93c2VyLiBJbiB0aGUgYnJvd3NlciwgQmxvYiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBGaWd1cmUgb3V0IGlmIHRoZXJlJ3MgYSB3YXkgdG8gc3Ryb25nbHkgdHlwZSAob3IgYXQgbGVhc3QgcnVudGltZSBjaGVjaykgdGhpc1xuICAgICAgICAgKiBzbyB0aGF0IHdlIGdldCBiYWNrIGludGVsbGlnZW50IGVycm9ycyB0aGF0IGFyZSBlbnZpcm9ubWVudC1kZXBlbmRlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBjb25maWcuZmlsZSBhcyBhbnksIGNvbmZpZz8uZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCBwcCA9IHBheWxvYWQgYXMgeyBba2V5OiBzdHJpbmddOiB1bmRlZmluZWQgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocHApKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwcFtrZXldO1xuICAgICAgICAgIGFkZE11bHRpcGFydHMoZm9ybURhdGEsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsUGF5bG9hZCA9IGZvcm1EYXRhO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBheWxvYWQgPT0gJ29iamVjdCcpIHtcbiAgICAgIGZpbmFsUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5hbFBheWxvYWQgPSBwYXlsb2FkO1xuICAgIH1cblxuICAgIGxldCByZXNwOiBBeGlvc1Jlc3BvbnNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh2ZXJiID09ICdQT1NUJykge1xuICAgICAgICByZXNwID0gYXdhaXQgZG9GZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IHZlcmIsXG4gICAgICAgICAgYm9keTogZmluYWxQYXlsb2FkIGFzIGFueSxcbiAgICAgICAgICBoZWFkZXJzOiByZXFDb25maWcuaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlc3AgPSBhd2FpdCBheGlvcy5wb3N0KHVybCwgZmluYWxQYXlsb2FkLCByZXFDb25maWcpO1xuICAgICAgfSBlbHNlIGlmICh2ZXJiID09ICdHRVQnKSB7XG4gICAgICAgIC8vIFRPRE86IEluY29ycG9yYXRlIHBhcmFtcyBpbnRvIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICB1cmwgPSB1cmwgKyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHBheWxvYWQgYXMgYW55KTtcbiAgICAgICAgfVxuICAgICAgICByZXNwID0gYXdhaXQgZG9GZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IHZlcmIsXG4gICAgICAgICAgaGVhZGVyczogcmVxQ29uZmlnLmhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZXNwID0gYXdhaXQgYXhpb3MuZ2V0KHVybCwgeyAuLi5yZXFDb25maWcsIHBhcmFtczogZmluYWxQYXlsb2FkIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0ZWFtc2hpcEVycm9yKHtcbiAgICAgICAgICBzdGF0dXNNZXNzYWdlOiBgVW5zdXBwb3J0ZWQgSFRUUCBWZXJiOiAke3ZlcmJ9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgdGhyb3cgdGhpcy5fbWFrZUVycm9yKHsgZXJyb3IgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX21ha2VSZXNwb25zZSh7XG4gICAgICByZXNwb25zZTogcmVzcCxcbiAgICAgIHJhd1Jlc3BvbnNlOiBjb25maWc/LnJhd1Jlc3BvbnNlLFxuICAgICAgb2JqZWN0Q29uc3RydWN0b3I6IGNvbmZpZz8uZXhwZWN0LFxuICAgICAgcmVzcG9uc2VQYXRoOiBjb25maWc/LnJlc3BvbnNlUGF0aCxcbiAgICB9KTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiK0NBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQSxPQUFPQSxLQUFLLE1BQXlCLE9BQU87QUFHNUMsT0FBT0MsU0FBUyxNQUFNLFVBQVU7QUFRaEMsU0FHRUMsaUJBQWlCLFFBQ1osMkJBQTJCO0FBQ2xDLFNBQVNDLGNBQWMsUUFBUSxzQkFBc0I7QUFDckQsU0FBU0MsSUFBSSxRQUFRLFdBQVc7QUFDaEMsU0FBcUJDLFNBQVMsUUFBUSxpQkFBaUI7QUFDdkQsU0FBU0MsTUFBTSxRQUFRLFlBQVk7QUFBQyxTQUVyQkMsT0FBTztFQUFBO0FBQUEsRUFTdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtFQUFBLHNFQXhCQSxrQkFBdUJDLEdBQVEsRUFBRUMsSUFBUztJQUFBO01BQUE7UUFBQTtVQUFBLGtDQUNqQ1QsS0FBSyxDQUFDO1lBQ1hRLEdBQUcsRUFBSEEsR0FBRztZQUNIRSxPQUFPLEVBQUVELElBQUksQ0FBQ0MsT0FBTztZQUNyQkMsSUFBSSxFQUFFRixJQUFJLENBQUNHLElBQUk7WUFDZkMsTUFBTSxFQUFFSixJ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