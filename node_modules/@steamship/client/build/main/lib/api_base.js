"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof3 = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ApiBase = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _axios = _interopRequireDefault(require("axios"));
var _log = _interopRequireDefault(require("./log.js"));
var _Configuration = require("./shared/Configuration.js");
var _steamship_error = require("./steamship_error.js");
var _task2 = require("./task.js");
var _base = require("./types/base.js");
var _utils = require("./utils.js");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function doFetch(_x, _x2) {
  return _doFetch.apply(this, arguments);
} // async function doFetch(url: any, opts: any): Promise<AxiosResponse> {
//   return new Promise<AxiosResponse>((resolve, reject) => {
//     axios({
//       url,
//       headers: opts.headers,
//       data: opts.body,
//       method: opts.method,
//     }).then(resolve)
//       .catch(
//         (err) => {
//           console.log(err);
//           reject(err);
//         }
//       )
//   })
// }
function _doFetch() {
  _doFetch = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(url, opts) {
    return _regenerator["default"].wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          return _context8.abrupt("return", (0, _axios["default"])({
            url: url,
            headers: opts.headers,
            data: opts.body,
            method: opts.method
          }));
        case 1:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  }));
  return _doFetch.apply(this, arguments);
}
var log = (0, _log["default"])('Steamship:ApiBase');
var MAX_BODY_LENGTH = 100000 * 1000;
var _IS_LOCAL = function _IS_LOCAL(base) {
  for (var _i = 0, _arr = ['localhost', '127.0.0.1', '0:0:0:0', ':3000', 'steamship.local', 'host.docker.internal', '/test:', '//app.staging.steamship.com',
    // For the demo user proxy trick - this is the website proxy
    '//app.steamship.com' // For the demo user proxy trick - this is the website proxy
    ]; _i < _arr.length; _i++) {
    var s = _arr[_i];
    if (base.includes(s)) {
      return true;
    }
  }
  return false;
};

/* Should be a FormData object */
function addMultiparts(formData, path, value) {
  /* Decode any object into a series of HTTP Multi-part segments that Vapor will consume.
    https://github.com/vapor/multipart-kit
     When sending a JSON object in a MultiPart request, Vapor wishes to see multi part segments as follows:
    single_key
    array_key[idx]
    obj_key[prop]
     So a File with a list of one tag with kind=Foo would be transmitted as setting the part:
    [tags][0][kind]
  */
  var type = (0, _typeof2["default"])(value);
  if (type == 'string' || type == 'boolean' || type == 'number') {
    formData.append(path, value);
  } else if (Array.isArray(value)) {
    value.forEach(function (subValue, index) {
      addMultiparts(formData, "".concat(path, "[").concat(index, "]"), subValue);
    });
  } else {
    for (var _key in value) {
      addMultiparts(formData, "".concat(path, "[").concat(_key, "]"), value[_key]);
    }
  }
}
var ApiBase = /*#__PURE__*/function () {
  function ApiBase(params) {
    var _this = this;
    (0, _classCallCheck2["default"])(this, ApiBase);
    (0, _defineProperty2["default"])(this, "config", void 0);
    this.config = (0, _Configuration.loadConfiguration)(params).then(function (config) {
      if (config.apiKey) {
        return _this._switchConfigWorkspace({
          workspaceHandle: params === null || params === void 0 ? void 0 : params.workspace,
          failIfWorkspaceExists: (params === null || params === void 0 ? void 0 : params.failIfWorkspaceExists) === true,
          config: config
        });
      } else {
        return config;
      }
    });
  }
  (0, _createClass2["default"])(ApiBase, [{
    key: "switchWorkspace",
    value: function () {
      var _switchWorkspace = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(params) {
        var config;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = this;
              _context.t1 = _objectSpread;
              _context.t2 = _objectSpread({}, params);
              _context.t3 = {};
              _context.next = 6;
              return this.config;
            case 6:
              _context.t4 = _context.sent;
              _context.t5 = {
                config: _context.t4
              };
              _context.t6 = (0, _context.t1)(_context.t2, _context.t3, _context.t5);
              _context.next = 11;
              return _context.t0._switchConfigWorkspace.call(_context.t0, _context.t6);
            case 11:
              config = _context.sent;
              this.config = Promise.resolve(config);
              log.info("Switched to workspace ".concat(config.workspaceHandle, "/").concat(config.workspaceId));
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function switchWorkspace(_x3) {
        return _switchWorkspace.apply(this, arguments);
      }
      return switchWorkspace;
    }()
    /*
      Switches this client to the requested workspace, possibly creating it. If all arguments are None, the client
      actively switches into the default workspace.
       - API calls are performed manually to not result in circular imports.
      - Note that the default workspace is technically not necessary for API usage; it will be assumed by the Engine
        in the absense of a Workspace ID or Handle being manually specified in request headers.
     */
  }, {
    key: "_switchConfigWorkspace",
    value: function () {
      var _switchConfigWorkspace2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(params) {
        var workspace, p, oldConfig, activeConfig, returnId, returnHandle;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              workspace = undefined;
              p = _objectSpread({}, params);
              if (!p.workspaceHandle) {
                p.workspaceHandle = 'default';
              }
              if (p.failIfWorkspaceExists) {
                log.info("Creating workspace with handle: ".concat(p.workspaceHandle, "."));
              } else {
                log.info("Creating/Fetching workspace with handle: ".concat(p.workspaceHandle, "."));
              }

              // Zero out the workspace_handle on the config block in case we're being invoked from
              // `init` (otherwise we'll attempt to create the sapce IN that nonexistant workspace)
              oldConfig = params.config;
              activeConfig = _objectSpread(_objectSpread({}, oldConfig), {}, {
                workspaceHandle: undefined,
                workspaceId: undefined
              });
              _context2.next = 8;
              return this.post('workspace/create', {
                handle: p.workspaceHandle,
                fetchIfExists: !(p.failIfWorkspaceExists === true)
              }, {
                responsePath: 'workspace'
              }, activeConfig);
            case 8:
              workspace = _context2.sent;
              if (!(!workspace || !workspace.output)) {
                _context2.next = 11;
                break;
              }
              throw new _steamship_error.SteamshipError({
                statusMessage: 'Was unable to switch to new workspace: server returned empty Workspace.'
              });
            case 11:
              returnId = workspace.output.id;
              returnHandle = workspace.output.handle;
              if (!(!returnHandle || !returnId)) {
                _context2.next = 16;
                break;
              }
              log.error(workspace);
              throw new _steamship_error.SteamshipError({
                statusMessage: "".concat(JSON.stringify(workspace), " Unable to switch to workspace ").concat(p.workspaceHandle, " with failIfWorkspaceExists ").concat(p.failIfWorkspaceExists, ": server returned empty ID and Handle.")
              });
            case 16:
              return _context2.abrupt("return", _objectSpread(_objectSpread({}, oldConfig), {}, {
                workspaceHandle: returnHandle,
                workspaceId: returnId
              }));
            case 17:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _switchConfigWorkspace(_x4) {
        return _switchConfigWorkspace2.apply(this, arguments);
      }
      return _switchConfigWorkspace;
    }()
  }, {
    key: "_headers",
    value: function _headers(config, postConfig) {
      var ret = {
        'Content-Type': 'application/json',
        Authorization: "Bearer ".concat(config.apiKey)
      };
      if (postConfig !== null && postConfig !== void 0 && postConfig.workspaceId) {
        ret['X-Workspace-Id'] = postConfig === null || postConfig === void 0 ? void 0 : postConfig.workspaceId;
      } else if (config.workspaceId) {
        ret['X-Workspace-Id'] = config.workspaceId;
      } else if (config.workspaceHandle) {
        ret['X-Workspace-Handle'] = config.workspaceHandle;
      }
      if ((postConfig === null || postConfig === void 0 ? void 0 : postConfig.isPackageCall) === true) {
        if (postConfig !== null && postConfig !== void 0 && postConfig.packageOwner) {
          ret['X-Package-Owner-Handle'] = postConfig.packageOwner;
        }
        if (postConfig !== null && postConfig !== void 0 && postConfig.packageId) {
          ret['X-Package-Id'] = postConfig.packageId;
        }
        if (postConfig !== null && postConfig !== void 0 && postConfig.packageInstanceId) {
          ret['X-Package-Instance-Id'] = postConfig.packageInstanceId;
        }
      }
      if ((postConfig === null || postConfig === void 0 ? void 0 : postConfig.asBackgroundTask) === true) {
        // Will result in the engine persisting the inbound HTTP request as a Task for deferred
        // execution. The client will receive task information back instead of the synchronous API response.
        // That task can be polled for eventual completion.
        ret['X-Task-Background'] = 'true';
      }
      return ret;
    }
  }, {
    key: "_url",
    value: function _url(baseConfig, postConfig, operation) {
      var base = '';
      if (!((postConfig === null || postConfig === void 0 ? void 0 : postConfig.isPackageCall) === true)) {
        // It's an API call
        base = (postConfig === null || postConfig === void 0 ? void 0 : postConfig.apiBase) || baseConfig.apiBase;
      } else {
        // It's a package call
        if (!(postConfig !== null && postConfig !== void 0 && postConfig.packageOwner)) {
          throw new _steamship_error.SteamshipError({
            statusCode: 'UserMissing',
            statusMessage: "Can not invoke an package endpoint without the package owner's user handle.",
            statusSuggestion: 'Provide the packageOwner option, or initialize your package with a lookup.'
          });
        }
        base = (postConfig === null || postConfig === void 0 ? void 0 : postConfig.appBase) || baseConfig.appBase;
        if (!base) {
          throw new _steamship_error.SteamshipError({
            statusCode: 'EndpointMissing',
            statusMessage: 'Can not invoke an package endpoint without the App Base variable set.',
            statusSuggestion: 'This should automatically have a good default setting. Reach out to our Steamship support.'
          });
        }
        if (!_IS_LOCAL(base)) {
          // Rewrite the base to be https://user.base
          var parts = base.split('//');
          if (parts.length < 2) {
            throw new _steamship_error.SteamshipError({
              statusCode: 'EndpointInvalid',
              statusMessage: 'You package base did not appear to begin with a valid HTTP or HTTPS protocol.',
              statusSuggestion: "Make sure you've provided an app base such as https://steamship.run, with the protocol."
            });
          }
          // Now we pre-pend the app-base to the first part!
          parts[1] = "".concat(postConfig === null || postConfig === void 0 ? void 0 : postConfig.packageOwner, ".").concat(parts[1]);
          base = parts.join('//');
        }
      }

      // Guard against a double // after the domain

      if (base && base[base.length - 1] == '/') {
        base = base.slice(0, base.length - 1);
      }
      if (operation && operation[0] == '/') {
        operation = operation.slice(1);
      }
      return "".concat(base, "/").concat(operation);
    }
  }, {
    key: "post",
    value: function () {
      var _post = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(operation, payload, config, overrideConfig) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.call('POST', operation, payload, config, overrideConfig));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function post(_x5, _x6, _x7, _x8) {
        return _post.apply(this, arguments);
      }
      return post;
    }()
  }, {
    key: "get",
    value: function () {
      var _get = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(operation, payload, config) {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", this.call('GET', operation, payload, config));
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function get(_x9, _x10, _x11) {
        return _get.apply(this, arguments);
      }
      return get;
    }()
  }, {
    key: "_makeError",
    value: function () {
      var _makeError2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(_ref) {
        var error, response, task, j;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              error = _ref.error, response = _ref.response, task = _ref.task;
              if (!error) {
                _context5.next = 5;
                break;
              }
              return _context5.abrupt("return", error);
            case 5:
              if (!response) {
                _context5.next = 20;
                break;
              }
              _context5.prev = 6;
              _context5.next = 9;
              return response.data;
            case 9:
              j = _context5.sent;
              if (!j.status) {
                _context5.next = 12;
                break;
              }
              return _context5.abrupt("return", new _steamship_error.SteamshipError({
                statusMessage: j.status.statusMessage,
                statusCode: j.status.statusCode,
                statusSuggestion: j.status.statusSuggestion
              }));
            case 12:
              _context5.next = 17;
              break;
            case 14:
              _context5.prev = 14;
              _context5.t0 = _context5["catch"](6);
              return _context5.abrupt("return", new _steamship_error.SteamshipError({
                statusMessage: 'Bad response from server'
              }));
            case 17:
              return _context5.abrupt("return", new _steamship_error.SteamshipError({
                statusMessage: 'Bad response from server'
              }));
            case 20:
              if (!task) {
                _context5.next = 22;
                break;
              }
              return _context5.abrupt("return", new _steamship_error.SteamshipError({
                statusMessage: task.statusMessage,
                statusCode: task.statusCode,
                statusSuggestion: task.statusSuggestion
              }));
            case 22:
              return _context5.abrupt("return", new _steamship_error.SteamshipError({
                statusMessage: 'Bad response'
              }));
            case 23:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[6, 14]]);
      }));
      function _makeError(_x12) {
        return _makeError2.apply(this, arguments);
      }
      return _makeError;
    }()
  }, {
    key: "_makeResponse",
    value: function () {
      var _makeResponse2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(_ref2) {
        var _json, _json2;
        var response, rawResponse, objectConstructor, responsePath, err, json, taskParams, task, _task;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              response = _ref2.response, rawResponse = _ref2.rawResponse, objectConstructor = _ref2.objectConstructor, responsePath = _ref2.responsePath;
              if (response) {
                _context6.next = 3;
                break;
              }
              throw new _steamship_error.SteamshipError({
                statusMessage: 'No response.'
              });
            case 3:
              if (!(response.status != 200)) {
                _context6.next = 8;
                break;
              }
              _context6.next = 6;
              return this._makeError({
                response: response
              });
            case 6:
              err = _context6.sent;
              throw err;
            case 8:
              if (!rawResponse) {
                _context6.next = 10;
                break;
              }
              return _context6.abrupt("return", response);
            case 10:
              _context6.prev = 10;
              json = response.data; // Axios
              // json = JSON.parse((response as any).body); // Got
              // json = await response.json(); // for the fetch style // Fetch
              _context6.next = 19;
              break;
            case 14:
              _context6.prev = 14;
              _context6.t0 = _context6["catch"](10);
              _context6.next = 18;
              return this._makeError({
                error: _context6.t0
              });
            case 18:
              throw _context6.sent;
            case 19:
              if (!(typeof json == 'undefined' || json == null)) {
                _context6.next = 21;
                break;
              }
              throw new _steamship_error.SteamshipError({
                statusMessage: 'Empty response.'
              });
            case 21:
              taskParams = (_json = json) === null || _json === void 0 ? void 0 : _json.status;
              if (!(typeof (taskParams === null || taskParams === void 0 ? void 0 : taskParams.state) != 'undefined')) {
                _context6.next = 30;
                break;
              }
              task = new _task2.Task(this, _objectSpread(_objectSpread({}, taskParams), {}, {
                responsePath: responsePath,
                rawResponse: rawResponse,
                objectConstructor: objectConstructor
              }));
              if (!(((_task = task) === null || _task === void 0 ? void 0 : _task.state) == _base.TaskState.failed)) {
                _context6.next = 28;
                break;
              }
              _context6.next = 27;
              return this._makeError({
                task: task
              });
            case 27:
              throw _context6.sent;
            case 28:
              _context6.next = 31;
              break;
            case 30:
              task = new _task2.Task(this, {
                responsePath: responsePath,
                rawResponse: rawResponse,
                objectConstructor: objectConstructor
              });
            case 31:
              task.setData((_json2 = json) === null || _json2 === void 0 ? void 0 : _json2.data);
              return _context6.abrupt("return", task);
            case 33:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[10, 14]]);
      }));
      function _makeResponse(_x13) {
        return _makeResponse2.apply(this, arguments);
      }
      return _makeResponse;
    }()
  }, {
    key: "call",
    value: function () {
      var _call = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(verb, operation, payload, config, overrideConfig) {
        var baseConfig, url, headers, reqConfig, finalPayload, contentType, FormDataNode, formData, pp, _i2, _Object$keys, _key2, value, _formData, _pp, _i3, _Object$keys2, _key3, _value, resp;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.t0 = overrideConfig;
              if (_context7.t0) {
                _context7.next = 5;
                break;
              }
              _context7.next = 4;
              return this.config;
            case 4:
              _context7.t0 = _context7.sent;
            case 5:
              baseConfig = _context7.t0;
              if (baseConfig.apiKey) {
                _context7.next = 8;
                break;
              }
              throw new _steamship_error.SteamshipError({
                statusCode: 'Authentication',
                statusMessage: 'API Key not found.',
                statusSuggestion: 'Please see docs.steamship.com for a variety of ways to set your API key.'
              });
            case 8:
              url = this._url(baseConfig, config, operation);
              headers = this._headers(baseConfig, config);
              reqConfig = {
                headers: headers,
                maxContentLength: MAX_BODY_LENGTH,
                maxBodyLength: MAX_BODY_LENGTH
              };
              finalPayload = undefined;
              if (!(verb == 'POST' && config !== null && config !== void 0 && config.file)) {
                _context7.next = 35;
                break;
              }
              contentType = undefined;
              if (typeof config.file != 'string') {
                contentType = 'binary/octet-stream';
              }

              // Important so proper boundary can be set;
              delete reqConfig.headers['Content-Type'];
              if (!(0, _utils.isNode)()) {
                _context7.next = 28;
                break;
              }
              _context7.next = 19;
              return Promise.resolve().then(function () {
                return _interopRequireWildcard(require('form-data'));
              });
            case 19:
              FormDataNode = _context7.sent;
              formData = new FormDataNode["default"]();
              formData.append('file', Buffer.from(config.file), {
                filename: config === null || config === void 0 ? void 0 : config.filename,
                contentType: contentType
              });
              pp = payload;
              for (_i2 = 0, _Object$keys = Object.keys(pp); _i2 < _Object$keys.length; _i2++) {
                _key2 = _Object$keys[_i2];
                value = pp[_key2];
                addMultiparts(formData, _key2, value);
              }
              finalPayload = formData;

              // This only needs to happen on Node.
              // And the .getHeaders method is unavilabile in the browser.
              // NOTE: This is untested in the unit tests; it will show up as a failure in the browser.
              // TODO: We need to start running tests inside a browser runtime too.
              reqConfig.headers = _objectSpread(_objectSpread({}, reqConfig.headers), formData.getHeaders());
              _context7.next = 33;
              break;
            case 28:
              _formData = new FormData();
              /*
               * The config.file as any cast below is because FormData does not support Buffer.
               * In general, file as a Buffer should only be done from within the NodeJS environment,
               * not from within the browser. In the browser, Blob should be used instead.
               *
               * TODO: Figure out if there's a way to strongly type (or at least runtime check) this
               * so that we get back intelligent errors that are environment-dependent.
               */
              _formData.append('file', config.file, config === null || config === void 0 ? void 0 : config.filename);
              _pp = payload;
              for (_i3 = 0, _Object$keys2 = Object.keys(_pp); _i3 < _Object$keys2.length; _i3++) {
                _key3 = _Object$keys2[_i3];
                _value = _pp[_key3];
                addMultiparts(_formData, _key3, _value);
              }
              finalPayload = _formData;
            case 33:
              _context7.next = 36;
              break;
            case 35:
              if ((0, _typeof2["default"])(payload) == 'object') {
                finalPayload = JSON.stringify(payload);
              } else {
                finalPayload = payload;
              }
            case 36:
              _context7.prev = 36;
              if (!(verb == 'POST')) {
                _context7.next = 43;
                break;
              }
              _context7.next = 40;
              return doFetch(url, {
                method: verb,
                body: finalPayload,
                headers: reqConfig.headers
              });
            case 40:
              resp = _context7.sent;
              _context7.next = 51;
              break;
            case 43:
              if (!(verb == 'GET')) {
                _context7.next = 50;
                break;
              }
              // TODO: Incorporate params into the query string
              if (payload) {
                url = url + '?' + new URLSearchParams(payload);
              }
              _context7.next = 47;
              return doFetch(url, {
                method: verb,
                headers: reqConfig.headers
              });
            case 47:
              resp = _context7.sent;
              _context7.next = 51;
              break;
            case 50:
              throw new _steamship_error.SteamshipError({
                statusMessage: "Unsupported HTTP Verb: ".concat(verb)
              });
            case 51:
              _context7.next = 56;
              break;
            case 53:
              _context7.prev = 53;
              _context7.t1 = _context7["catch"](36);
              throw this._makeError({
                error: _context7.t1
              });
            case 56:
              return _context7.abrupt("return", this._makeResponse({
                response: resp,
                rawResponse: config === null || config === void 0 ? void 0 : config.rawResponse,
                objectConstructor: config === null || config === void 0 ? void 0 : config.expect,
                responsePath: config === null || config === void 0 ? void 0 : config.responsePath
              }));
            case 57:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[36, 53]]);
      }));
      function call(_x14, _x15, _x16, _x17, _x18) {
        return _call.apply(this, arguments);
      }
      return call;
    }()
  }]);
  return ApiBase;
}();
exports.ApiBase = ApiBase;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb0ZldGNoIiwidXJsIiwib3B0cyIsImF4aW9zIiwiaGVhZGVycyIsImRhdGEiLCJib2R5IiwibWV0aG9kIiwibG9nIiwiZ2V0TG9nZ2VyIiwiTUFYX0JPRFlfTEVOR1RIIiwiX0lTX0xPQ0FMIiwiYmFzZSIsInMiLCJpbmNsdWRlcyIsImFkZE11bHRpcGFydHMiLCJmb3JtRGF0YSIsInBhdGgiLCJ2YWx1ZSIsInR5cGUiLCJhcHBlbmQiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwic3ViVmFsdWUiLCJpbmRleCIsImtleSIsIkFwaUJhc2UiLCJwYXJhbXMiLCJjb25maWciLCJsb2FkQ29uZmlndXJhdGlvbiIsInRoZW4iLCJhcGlLZXkiLCJfc3dpdGNoQ29uZmlnV29ya3NwYWNlIiwid29ya3NwYWNlSGFuZGxlIiwid29ya3NwYWNlIiwiZmFpbElmV29ya3NwYWNlRXhpc3RzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbmZvIiwid29ya3NwYWNlSWQiLCJ1bmRlZmluZWQiLCJwIiwib2xkQ29uZmlnIiwiYWN0aXZlQ29uZmlnIiwicG9zdCIsImhhbmRsZSIsImZldGNoSWZFeGlzdHMiLCJyZXNwb25zZVBhdGgiLCJvdXRwdXQiLCJTdGVhbXNoaXBFcnJvciIsInN0YXR1c01lc3NhZ2UiLCJyZXR1cm5JZCIsImlkIiwicmV0dXJuSGFuZGxlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwicG9zdENvbmZpZyIsInJldCIsIkF1dGhvcml6YXRpb24iLCJpc1BhY2thZ2VDYWxsIiwicGFja2FnZU93bmVyIiwicGFja2FnZUlkIiwicGFja2FnZUluc3RhbmNlSWQiLCJhc0JhY2tncm91bmRUYXNrIiwiYmFzZUNvbmZpZyIsIm9wZXJhdGlvbiIsImFwaUJhc2UiLCJzdGF0dXNDb2RlIiwic3RhdHVzU3VnZ2VzdGlvbiIsImFwcEJhc2UiLCJwYXJ0cyIsInNwbGl0IiwibGVuZ3RoIiwiam9pbiIsInNsaWNlIiwicGF5bG9hZCIsIm92ZXJyaWRlQ29uZmlnIiwiY2FsbCIsInJlc3BvbnNlIiwidGFzayIsImoiLCJzdGF0dXMiLCJyYXdSZXNwb25zZSIsIm9iamVjdENvbnN0cnVjdG9yIiwiX21ha2VFcnJvciIsImVyciIsImpzb24iLCJ0YXNrUGFyYW1zIiwic3RhdGUiLCJUYXNrIiwiVGFza1N0YXRlIiwiZmFpbGVkIiwic2V0RGF0YSIsInZlcmIiLCJfdXJsIiwiX2hlYWRlcnMiLCJyZXFDb25maWciLCJtYXhDb250ZW50TGVuZ3RoIiwibWF4Qm9keUxlbmd0aCIsImZpbmFsUGF5bG9hZCIsImZpbGUiLCJjb250ZW50VHlwZSIsImlzTm9kZSIsIkZvcm1EYXRhTm9kZSIsIkJ1ZmZlciIsImZyb20iLCJmaWxlbmFtZSIsInBwIiwiT2JqZWN0Iiwia2V5cyIsImdldEhlYWRlcnMiLCJGb3JtRGF0YSIsInJlc3AiLCJVUkxTZWFyY2hQYXJhbXMiLCJfbWFrZVJlc3BvbnNlIiwiZXhwZWN0Il0sInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9hcGlfYmFzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MsIHsgQXhpb3NSZXNwb25zZSB9IGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ3RzbG9nJztcblxuaW1wb3J0IGdldExvZ2dlciBmcm9tICcuL2xvZy5qcyc7XG5pbXBvcnQge1xuICBJQXBpQmFzZSxcbiAgSVRhc2ssXG4gIFBvc3RDb25maWcsXG4gIFN3aXRjaFdvcmtzcGFjZVBhcmFtcyxcbiAgVmVyYixcbn0gZnJvbSAnLi9zaGFyZWQvQmFzZUludGVyZmFjZXMuanMnO1xuaW1wb3J0IHtcbiAgQ29uZmlndXJhdGlvbixcbiAgTG9hZENvbmZpZ1BhcmFtcyxcbiAgbG9hZENvbmZpZ3VyYXRpb24sXG59IGZyb20gJy4vc2hhcmVkL0NvbmZpZ3VyYXRpb24uanMnO1xuaW1wb3J0IHsgU3RlYW1zaGlwRXJyb3IgfSBmcm9tICcuL3N0ZWFtc2hpcF9lcnJvci5qcyc7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi90YXNrLmpzJztcbmltcG9ydCB7IFRhc2tQYXJhbXMsIFRhc2tTdGF0ZSB9IGZyb20gJy4vdHlwZXMvYmFzZS5qcyc7XG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuYXN5bmMgZnVuY3Rpb24gZG9GZXRjaCh1cmw6IGFueSwgb3B0czogYW55KTogUHJvbWlzZTxBeGlvc1Jlc3BvbnNlPiB7XG4gIHJldHVybiBheGlvcyh7XG4gICAgdXJsLFxuICAgIGhlYWRlcnM6IG9wdHMuaGVhZGVycyxcbiAgICBkYXRhOiBvcHRzLmJvZHksXG4gICAgbWV0aG9kOiBvcHRzLm1ldGhvZCxcbiAgfSk7XG59XG5cbi8vIGFzeW5jIGZ1bmN0aW9uIGRvRmV0Y2godXJsOiBhbnksIG9wdHM6IGFueSk6IFByb21pc2U8QXhpb3NSZXNwb25zZT4ge1xuLy8gICByZXR1cm4gbmV3IFByb21pc2U8QXhpb3NSZXNwb25zZT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuLy8gICAgIGF4aW9zKHtcbi8vICAgICAgIHVybCxcbi8vICAgICAgIGhlYWRlcnM6IG9wdHMuaGVhZGVycyxcbi8vICAgICAgIGRhdGE6IG9wdHMuYm9keSxcbi8vICAgICAgIG1ldGhvZDogb3B0cy5tZXRob2QsXG4vLyAgICAgfSkudGhlbihyZXNvbHZlKVxuLy8gICAgICAgLmNhdGNoKFxuLy8gICAgICAgICAoZXJyKSA9PiB7XG4vLyAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbi8vICAgICAgICAgICByZWplY3QoZXJyKTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgKVxuLy8gICB9KVxuLy8gfVxuXG5jb25zdCBsb2c6IExvZ2dlciA9IGdldExvZ2dlcignU3RlYW1zaGlwOkFwaUJhc2UnKTtcblxuY29uc3QgTUFYX0JPRFlfTEVOR1RIID0gMTAwMDAwICogMTAwMDtcblxuY29uc3QgX0lTX0xPQ0FMID0gKGJhc2U6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICBmb3IgKGNvbnN0IHMgb2YgW1xuICAgICdsb2NhbGhvc3QnLFxuICAgICcxMjcuMC4wLjEnLFxuICAgICcwOjA6MDowJyxcbiAgICAnOjMwMDAnLFxuICAgICdzdGVhbXNoaXAubG9jYWwnLFxuICAgICdob3N0LmRvY2tlci5pbnRlcm5hbCcsXG4gICAgJy90ZXN0OicsXG4gICAgJy8vYXBwLnN0YWdpbmcuc3RlYW1zaGlwLmNvbScsIC8vIEZvciB0aGUgZGVtbyB1c2VyIHByb3h5IHRyaWNrIC0gdGhpcyBpcyB0aGUgd2Vic2l0ZSBwcm94eVxuICAgICcvL2FwcC5zdGVhbXNoaXAuY29tJywgLy8gRm9yIHRoZSBkZW1vIHVzZXIgcHJveHkgdHJpY2sgLSB0aGlzIGlzIHRoZSB3ZWJzaXRlIHByb3h5XG4gIF0pIHtcbiAgICBpZiAoYmFzZS5pbmNsdWRlcyhzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qIFNob3VsZCBiZSBhIEZvcm1EYXRhIG9iamVjdCAqL1xuZnVuY3Rpb24gYWRkTXVsdGlwYXJ0cyhmb3JtRGF0YTogYW55LCBwYXRoOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgLyogRGVjb2RlIGFueSBvYmplY3QgaW50byBhIHNlcmllcyBvZiBIVFRQIE11bHRpLXBhcnQgc2VnbWVudHMgdGhhdCBWYXBvciB3aWxsIGNvbnN1bWUuXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL3ZhcG9yL211bHRpcGFydC1raXRcblxuICAgIFdoZW4gc2VuZGluZyBhIEpTT04gb2JqZWN0IGluIGEgTXVsdGlQYXJ0IHJlcXVlc3QsIFZhcG9yIHdpc2hlcyB0byBzZWUgbXVsdGkgcGFydCBzZWdtZW50cyBhcyBmb2xsb3dzOlxuICAgIHNpbmdsZV9rZXlcbiAgICBhcnJheV9rZXlbaWR4XVxuICAgIG9ial9rZXlbcHJvcF1cblxuICAgIFNvIGEgRmlsZSB3aXRoIGEgbGlzdCBvZiBvbmUgdGFnIHdpdGgga2luZD1Gb28gd291bGQgYmUgdHJhbnNtaXR0ZWQgYXMgc2V0dGluZyB0aGUgcGFydDpcbiAgICBbdGFnc11bMF1ba2luZF1cbiAgKi9cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHwgdHlwZSA9PSAnbnVtYmVyJykge1xuICAgIGZvcm1EYXRhLmFwcGVuZChwYXRoLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKChzdWJWYWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGFkZE11bHRpcGFydHMoZm9ybURhdGEsIGAke3BhdGh9WyR7aW5kZXh9XWAsIHN1YlZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgYWRkTXVsdGlwYXJ0cyhmb3JtRGF0YSwgYCR7cGF0aH1bJHtrZXl9XWAsIHZhbHVlW2tleV0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN3aXRjaENvbmZpZ1dvcmtzcGFjZVBhcmFtcyB7XG4gIHdvcmtzcGFjZUhhbmRsZT86IHN0cmluZztcbiAgZmFpbElmV29ya3NwYWNlRXhpc3RzPzogYm9vbGVhbjtcbiAgY29uZmlnOiBDb25maWd1cmF0aW9uO1xufVxuXG5leHBvcnQgY2xhc3MgQXBpQmFzZSBpbXBsZW1lbnRzIElBcGlCYXNlIHtcbiAgY29uZmlnOiBQcm9taXNlPENvbmZpZ3VyYXRpb24+IHwgQ29uZmlndXJhdGlvbjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocGFyYW1zPzogTG9hZENvbmZpZ1BhcmFtcykge1xuICAgIHRoaXMuY29uZmlnID0gbG9hZENvbmZpZ3VyYXRpb24ocGFyYW1zKS50aGVuKChjb25maWcpID0+IHtcbiAgICAgIGlmIChjb25maWcuYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zd2l0Y2hDb25maWdXb3Jrc3BhY2Uoe1xuICAgICAgICAgIHdvcmtzcGFjZUhhbmRsZTogcGFyYW1zPy53b3Jrc3BhY2UsXG4gICAgICAgICAgZmFpbElmV29ya3NwYWNlRXhpc3RzOiBwYXJhbXM/LmZhaWxJZldvcmtzcGFjZUV4aXN0cyA9PT0gdHJ1ZSxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHN3aXRjaFdvcmtzcGFjZShwYXJhbXM/OiBTd2l0Y2hXb3Jrc3BhY2VQYXJhbXMpIHtcbiAgICBjb25zdCBjb25maWcgPSBhd2FpdCB0aGlzLl9zd2l0Y2hDb25maWdXb3Jrc3BhY2Uoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgY29uZmlnOiBhd2FpdCB0aGlzLmNvbmZpZyxcbiAgICB9KTtcbiAgICB0aGlzLmNvbmZpZyA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuICAgIGxvZy5pbmZvKFxuICAgICAgYFN3aXRjaGVkIHRvIHdvcmtzcGFjZSAke2NvbmZpZy53b3Jrc3BhY2VIYW5kbGV9LyR7Y29uZmlnLndvcmtzcGFjZUlkfWBcbiAgICApO1xuICB9XG5cbiAgLypcbiAgICBTd2l0Y2hlcyB0aGlzIGNsaWVudCB0byB0aGUgcmVxdWVzdGVkIHdvcmtzcGFjZSwgcG9zc2libHkgY3JlYXRpbmcgaXQuIElmIGFsbCBhcmd1bWVudHMgYXJlIE5vbmUsIHRoZSBjbGllbnRcbiAgICBhY3RpdmVseSBzd2l0Y2hlcyBpbnRvIHRoZSBkZWZhdWx0IHdvcmtzcGFjZS5cblxuICAgIC0gQVBJIGNhbGxzIGFyZSBwZXJmb3JtZWQgbWFudWFsbHkgdG8gbm90IHJlc3VsdCBpbiBjaXJjdWxhciBpbXBvcnRzLlxuICAgIC0gTm90ZSB0aGF0IHRoZSBkZWZhdWx0IHdvcmtzcGFjZSBpcyB0ZWNobmljYWxseSBub3QgbmVjZXNzYXJ5IGZvciBBUEkgdXNhZ2U7IGl0IHdpbGwgYmUgYXNzdW1lZCBieSB0aGUgRW5naW5lXG4gICAgICBpbiB0aGUgYWJzZW5zZSBvZiBhIFdvcmtzcGFjZSBJRCBvciBIYW5kbGUgYmVpbmcgbWFudWFsbHkgc3BlY2lmaWVkIGluIHJlcXVlc3QgaGVhZGVycy5cbiAgICovXG4gIGFzeW5jIF9zd2l0Y2hDb25maWdXb3Jrc3BhY2UoXG4gICAgcGFyYW1zOiBTd2l0Y2hDb25maWdXb3Jrc3BhY2VQYXJhbXNcbiAgKTogUHJvbWlzZTxDb25maWd1cmF0aW9uPiB7XG4gICAgbGV0IHdvcmtzcGFjZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHA6IFN3aXRjaFdvcmtzcGFjZVBhcmFtcyA9IHsgLi4ucGFyYW1zIH07XG5cbiAgICBpZiAoIXAud29ya3NwYWNlSGFuZGxlKSB7XG4gICAgICBwLndvcmtzcGFjZUhhbmRsZSA9ICdkZWZhdWx0JztcbiAgICB9XG5cbiAgICBpZiAocC5mYWlsSWZXb3Jrc3BhY2VFeGlzdHMpIHtcbiAgICAgIGxvZy5pbmZvKGBDcmVhdGluZyB3b3Jrc3BhY2Ugd2l0aCBoYW5kbGU6ICR7cC53b3Jrc3BhY2VIYW5kbGV9LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuaW5mbyhcbiAgICAgICAgYENyZWF0aW5nL0ZldGNoaW5nIHdvcmtzcGFjZSB3aXRoIGhhbmRsZTogJHtwLndvcmtzcGFjZUhhbmRsZX0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBaZXJvIG91dCB0aGUgd29ya3NwYWNlX2hhbmRsZSBvbiB0aGUgY29uZmlnIGJsb2NrIGluIGNhc2Ugd2UncmUgYmVpbmcgaW52b2tlZCBmcm9tXG4gICAgLy8gYGluaXRgIChvdGhlcndpc2Ugd2UnbGwgYXR0ZW1wdCB0byBjcmVhdGUgdGhlIHNhcGNlIElOIHRoYXQgbm9uZXhpc3RhbnQgd29ya3NwYWNlKVxuICAgIGNvbnN0IG9sZENvbmZpZyA9IHBhcmFtcy5jb25maWc7XG5cbiAgICBjb25zdCBhY3RpdmVDb25maWcgPSB7XG4gICAgICAuLi5vbGRDb25maWcsXG4gICAgICB3b3Jrc3BhY2VIYW5kbGU6IHVuZGVmaW5lZCxcbiAgICAgIHdvcmtzcGFjZUlkOiB1bmRlZmluZWQsXG4gICAgfTtcblxuICAgIHdvcmtzcGFjZSA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgICd3b3Jrc3BhY2UvY3JlYXRlJyxcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlOiBwLndvcmtzcGFjZUhhbmRsZSxcbiAgICAgICAgZmV0Y2hJZkV4aXN0czogIShwLmZhaWxJZldvcmtzcGFjZUV4aXN0cyA9PT0gdHJ1ZSksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZXNwb25zZVBhdGg6ICd3b3Jrc3BhY2UnLFxuICAgICAgfSxcbiAgICAgIGFjdGl2ZUNvbmZpZ1xuICAgICk7XG5cbiAgICBpZiAoIXdvcmtzcGFjZSB8fCAhd29ya3NwYWNlLm91dHB1dCkge1xuICAgICAgdGhyb3cgbmV3IFN0ZWFtc2hpcEVycm9yKHtcbiAgICAgICAgc3RhdHVzTWVzc2FnZTpcbiAgICAgICAgICAnV2FzIHVuYWJsZSB0byBzd2l0Y2ggdG8gbmV3IHdvcmtzcGFjZTogc2VydmVyIHJldHVybmVkIGVtcHR5IFdvcmtzcGFjZS4nLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmV0dXJuSWQ6IHN0cmluZyA9IHdvcmtzcGFjZS5vdXRwdXQuaWQ7XG4gICAgY29uc3QgcmV0dXJuSGFuZGxlOiBzdHJpbmcgPSB3b3Jrc3BhY2Uub3V0cHV0LmhhbmRsZTtcblxuICAgIGlmICghcmV0dXJuSGFuZGxlIHx8ICFyZXR1cm5JZCkge1xuICAgICAgbG9nLmVycm9yKHdvcmtzcGFjZSk7XG4gICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICBzdGF0dXNNZXNzYWdlOiBgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB3b3Jrc3BhY2VcbiAgICAgICAgKX0gVW5hYmxlIHRvIHN3aXRjaCB0byB3b3Jrc3BhY2UgJHtcbiAgICAgICAgICBwLndvcmtzcGFjZUhhbmRsZVxuICAgICAgICB9IHdpdGggZmFpbElmV29ya3NwYWNlRXhpc3RzICR7XG4gICAgICAgICAgcC5mYWlsSWZXb3Jrc3BhY2VFeGlzdHNcbiAgICAgICAgfTogc2VydmVyIHJldHVybmVkIGVtcHR5IElEIGFuZCBIYW5kbGUuYCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIHNldCB0aGUgbmV3IHdvcmtzcGFjZVxuICAgIHJldHVybiB7XG4gICAgICAuLi5vbGRDb25maWcsXG4gICAgICB3b3Jrc3BhY2VIYW5kbGU6IHJldHVybkhhbmRsZSxcbiAgICAgIHdvcmtzcGFjZUlkOiByZXR1cm5JZCxcbiAgICB9O1xuICB9XG5cbiAgX2hlYWRlcnM8VD4oXG4gICAgY29uZmlnOiBDb25maWd1cmF0aW9uLFxuICAgIHBvc3RDb25maWc/OiBQb3N0Q29uZmlnPFQ+XG4gICk6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9IHtcbiAgICBjb25zdCByZXQ6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb25maWcuYXBpS2V5fWAsXG4gICAgfTtcblxuICAgIGlmIChwb3N0Q29uZmlnPy53b3Jrc3BhY2VJZCkge1xuICAgICAgcmV0WydYLVdvcmtzcGFjZS1JZCddID0gcG9zdENvbmZpZz8ud29ya3NwYWNlSWQ7XG4gICAgfSBlbHNlIGlmIChjb25maWcud29ya3NwYWNlSWQpIHtcbiAgICAgIHJldFsnWC1Xb3Jrc3BhY2UtSWQnXSA9IGNvbmZpZy53b3Jrc3BhY2VJZDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy53b3Jrc3BhY2VIYW5kbGUpIHtcbiAgICAgIHJldFsnWC1Xb3Jrc3BhY2UtSGFuZGxlJ10gPSBjb25maWcud29ya3NwYWNlSGFuZGxlO1xuICAgIH1cblxuICAgIGlmIChwb3N0Q29uZmlnPy5pc1BhY2thZ2VDYWxsID09PSB0cnVlKSB7XG4gICAgICBpZiAocG9zdENvbmZpZz8ucGFja2FnZU93bmVyKSB7XG4gICAgICAgIHJldFsnWC1QYWNrYWdlLU93bmVyLUhhbmRsZSddID0gcG9zdENvbmZpZy5wYWNrYWdlT3duZXI7XG4gICAgICB9XG4gICAgICBpZiAocG9zdENvbmZpZz8ucGFja2FnZUlkKSB7XG4gICAgICAgIHJldFsnWC1QYWNrYWdlLUlkJ10gPSBwb3N0Q29uZmlnLnBhY2thZ2VJZDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3N0Q29uZmlnPy5wYWNrYWdlSW5zdGFuY2VJZCkge1xuICAgICAgICByZXRbJ1gtUGFja2FnZS1JbnN0YW5jZS1JZCddID0gcG9zdENvbmZpZy5wYWNrYWdlSW5zdGFuY2VJZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zdENvbmZpZz8uYXNCYWNrZ3JvdW5kVGFzayA9PT0gdHJ1ZSkge1xuICAgICAgLy8gV2lsbCByZXN1bHQgaW4gdGhlIGVuZ2luZSBwZXJzaXN0aW5nIHRoZSBpbmJvdW5kIEhUVFAgcmVxdWVzdCBhcyBhIFRhc2sgZm9yIGRlZmVycmVkXG4gICAgICAvLyBleGVjdXRpb24uIFRoZSBjbGllbnQgd2lsbCByZWNlaXZlIHRhc2sgaW5mb3JtYXRpb24gYmFjayBpbnN0ZWFkIG9mIHRoZSBzeW5jaHJvbm91cyBBUEkgcmVzcG9uc2UuXG4gICAgICAvLyBUaGF0IHRhc2sgY2FuIGJlIHBvbGxlZCBmb3IgZXZlbnR1YWwgY29tcGxldGlvbi5cbiAgICAgIHJldFsnWC1UYXNrLUJhY2tncm91bmQnXSA9ICd0cnVlJztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIF91cmw8VD4oXG4gICAgYmFzZUNvbmZpZzogQ29uZmlndXJhdGlvbixcbiAgICBwb3N0Q29uZmlnPzogUG9zdENvbmZpZzxUPixcbiAgICBvcGVyYXRpb24/OiBzdHJpbmdcbiAgKTogc3RyaW5nIHtcbiAgICBsZXQgYmFzZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gJyc7XG5cbiAgICBpZiAoIShwb3N0Q29uZmlnPy5pc1BhY2thZ2VDYWxsID09PSB0cnVlKSkge1xuICAgICAgLy8gSXQncyBhbiBBUEkgY2FsbFxuICAgICAgYmFzZSA9IHBvc3RDb25maWc/LmFwaUJhc2UgfHwgYmFzZUNvbmZpZy5hcGlCYXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJdCdzIGEgcGFja2FnZSBjYWxsXG4gICAgICBpZiAoIXBvc3RDb25maWc/LnBhY2thZ2VPd25lcikge1xuICAgICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICAgIHN0YXR1c0NvZGU6ICdVc2VyTWlzc2luZycsXG4gICAgICAgICAgc3RhdHVzTWVzc2FnZTpcbiAgICAgICAgICAgIFwiQ2FuIG5vdCBpbnZva2UgYW4gcGFja2FnZSBlbmRwb2ludCB3aXRob3V0IHRoZSBwYWNrYWdlIG93bmVyJ3MgdXNlciBoYW5kbGUuXCIsXG4gICAgICAgICAgc3RhdHVzU3VnZ2VzdGlvbjpcbiAgICAgICAgICAgICdQcm92aWRlIHRoZSBwYWNrYWdlT3duZXIgb3B0aW9uLCBvciBpbml0aWFsaXplIHlvdXIgcGFja2FnZSB3aXRoIGEgbG9va3VwLicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBiYXNlID0gcG9zdENvbmZpZz8uYXBwQmFzZSB8fCBiYXNlQ29uZmlnLmFwcEJhc2U7XG5cbiAgICAgIGlmICghYmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICAgIHN0YXR1c0NvZGU6ICdFbmRwb2ludE1pc3NpbmcnLFxuICAgICAgICAgIHN0YXR1c01lc3NhZ2U6XG4gICAgICAgICAgICAnQ2FuIG5vdCBpbnZva2UgYW4gcGFja2FnZSBlbmRwb2ludCB3aXRob3V0IHRoZSBBcHAgQmFzZSB2YXJpYWJsZSBzZXQuJyxcbiAgICAgICAgICBzdGF0dXNTdWdnZXN0aW9uOlxuICAgICAgICAgICAgJ1RoaXMgc2hvdWxkIGF1dG9tYXRpY2FsbHkgaGF2ZSBhIGdvb2QgZGVmYXVsdCBzZXR0aW5nLiBSZWFjaCBvdXQgdG8gb3VyIFN0ZWFtc2hpcCBzdXBwb3J0LicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9JU19MT0NBTChiYXNlKSkge1xuICAgICAgICAvLyBSZXdyaXRlIHRoZSBiYXNlIHRvIGJlIGh0dHBzOi8vdXNlci5iYXNlXG4gICAgICAgIGNvbnN0IHBhcnRzID0gYmFzZS5zcGxpdCgnLy8nKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogJ0VuZHBvaW50SW52YWxpZCcsXG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlOlxuICAgICAgICAgICAgICAnWW91IHBhY2thZ2UgYmFzZSBkaWQgbm90IGFwcGVhciB0byBiZWdpbiB3aXRoIGEgdmFsaWQgSFRUUCBvciBIVFRQUyBwcm90b2NvbC4nLFxuICAgICAgICAgICAgc3RhdHVzU3VnZ2VzdGlvbjpcbiAgICAgICAgICAgICAgXCJNYWtlIHN1cmUgeW91J3ZlIHByb3ZpZGVkIGFuIGFwcCBiYXNlIHN1Y2ggYXMgaHR0cHM6Ly9zdGVhbXNoaXAucnVuLCB3aXRoIHRoZSBwcm90b2NvbC5cIixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgd2UgcHJlLXBlbmQgdGhlIGFwcC1iYXNlIHRvIHRoZSBmaXJzdCBwYXJ0IVxuICAgICAgICBwYXJ0c1sxXSA9IGAke3Bvc3RDb25maWc/LnBhY2thZ2VPd25lcn0uJHtwYXJ0c1sxXX1gO1xuICAgICAgICBiYXNlID0gcGFydHMuam9pbignLy8nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHdWFyZCBhZ2FpbnN0IGEgZG91YmxlIC8vIGFmdGVyIHRoZSBkb21haW5cblxuICAgIGlmIChiYXNlICYmIGJhc2VbYmFzZS5sZW5ndGggLSAxXSA9PSAnLycpIHtcbiAgICAgIGJhc2UgPSBiYXNlLnNsaWNlKDAsIGJhc2UubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGlmIChvcGVyYXRpb24gJiYgb3BlcmF0aW9uWzBdID09ICcvJykge1xuICAgICAgb3BlcmF0aW9uID0gb3BlcmF0aW9uLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7YmFzZX0vJHtvcGVyYXRpb259YDtcbiAgfVxuXG4gIGFzeW5jIHBvc3Q8VD4oXG4gICAgb3BlcmF0aW9uOiBzdHJpbmcsXG4gICAgcGF5bG9hZDogdW5rbm93bixcbiAgICBjb25maWc/OiBQb3N0Q29uZmlnPFQ+LFxuICAgIG92ZXJyaWRlQ29uZmlnPzogQ29uZmlndXJhdGlvblxuICApOiBQcm9taXNlPEF4aW9zUmVzcG9uc2UgfCBJVGFzazxUPj4ge1xuICAgIHJldHVybiB0aGlzLmNhbGwoJ1BPU1QnLCBvcGVyYXRpb24sIHBheWxvYWQsIGNvbmZpZywgb3ZlcnJpZGVDb25maWcpO1xuICB9XG5cbiAgYXN5bmMgZ2V0PFQ+KFxuICAgIG9wZXJhdGlvbjogc3RyaW5nLFxuICAgIHBheWxvYWQ6IHVua25vd24sXG4gICAgY29uZmlnPzogUG9zdENvbmZpZzxUPlxuICApOiBQcm9taXNlPEF4aW9zUmVzcG9uc2UgfCBJVGFzazxUPj4ge1xuICAgIHJldHVybiB0aGlzLmNhbGwoJ0dFVCcsIG9wZXJhdGlvbiwgcGF5bG9hZCwgY29uZmlnKTtcbiAgfVxuXG4gIGFzeW5jIF9tYWtlRXJyb3I8VD4oe1xuICAgIGVycm9yLFxuICAgIHJlc3BvbnNlLFxuICAgIHRhc2ssXG4gIH06IHtcbiAgICBlcnJvcj86IEVycm9yO1xuICAgIHJlc3BvbnNlPzogQXhpb3NSZXNwb25zZTtcbiAgICB0YXNrPzogSVRhc2s8VD47XG4gIH0pOiBQcm9taXNlPEVycm9yPiB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaiA9IGF3YWl0IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChqLnN0YXR1cykge1xuICAgICAgICAgIHJldHVybiBuZXcgU3RlYW1zaGlwRXJyb3Ioe1xuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogai5zdGF0dXMuc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IGouc3RhdHVzLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICBzdGF0dXNTdWdnZXN0aW9uOiBqLnN0YXR1cy5zdGF0dXNTdWdnZXN0aW9uLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVhbXNoaXBFcnJvcih7XG4gICAgICAgICAgc3RhdHVzTWVzc2FnZTogJ0JhZCByZXNwb25zZSBmcm9tIHNlcnZlcicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTdGVhbXNoaXBFcnJvcih7IHN0YXR1c01lc3NhZ2U6ICdCYWQgcmVzcG9uc2UgZnJvbSBzZXJ2ZXInIH0pO1xuICAgIH0gZWxzZSBpZiAodGFzaykge1xuICAgICAgcmV0dXJuIG5ldyBTdGVhbXNoaXBFcnJvcih7XG4gICAgICAgIHN0YXR1c01lc3NhZ2U6IHRhc2suc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgc3RhdHVzQ29kZTogdGFzay5zdGF0dXNDb2RlLFxuICAgICAgICBzdGF0dXNTdWdnZXN0aW9uOiB0YXNrLnN0YXR1c1N1Z2dlc3Rpb24sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdGVhbXNoaXBFcnJvcih7IHN0YXR1c01lc3NhZ2U6ICdCYWQgcmVzcG9uc2UnIH0pO1xuICB9XG5cbiAgYXN5bmMgX21ha2VSZXNwb25zZTxUPih7XG4gICAgcmVzcG9uc2UsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgb2JqZWN0Q29uc3RydWN0b3IsXG4gICAgcmVzcG9uc2VQYXRoLFxuICB9OiB7XG4gICAgcmVzcG9uc2U6IEF4aW9zUmVzcG9uc2U7XG4gICAgcmF3UmVzcG9uc2U/OiBib29sZWFuO1xuICAgIHJlc3BvbnNlUGF0aD86IHN0cmluZztcbiAgICBvYmplY3RDb25zdHJ1Y3Rvcj86IChjbGllbnQ6IGFueSwgZGF0YTogYW55KSA9PiBUO1xuICB9KTogUHJvbWlzZTxUYXNrPFQ+IHwgQXhpb3NSZXNwb25zZT4ge1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHRocm93IG5ldyBTdGVhbXNoaXBFcnJvcih7IHN0YXR1c01lc3NhZ2U6ICdObyByZXNwb25zZS4nIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT0gMjAwKSB7XG4gICAgICBjb25zdCBlcnIgPSBhd2FpdCB0aGlzLl9tYWtlRXJyb3IoeyByZXNwb25zZSB9KTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpZiAocmF3UmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBsZXQganNvbjogYW55O1xuICAgIHRyeSB7XG4gICAgICBqc29uID0gcmVzcG9uc2UuZGF0YTsgLy8gQXhpb3NcbiAgICAgIC8vIGpzb24gPSBKU09OLnBhcnNlKChyZXNwb25zZSBhcyBhbnkpLmJvZHkpOyAvLyBHb3RcbiAgICAgIC8vIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7IC8vIGZvciB0aGUgZmV0Y2ggc3R5bGUgLy8gRmV0Y2hcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICB0aHJvdyBhd2FpdCB0aGlzLl9tYWtlRXJyb3IoeyBlcnJvciB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGpzb24gPT0gJ3VuZGVmaW5lZCcgfHwganNvbiA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgU3RlYW1zaGlwRXJyb3IoeyBzdGF0dXNNZXNzYWdlOiAnRW1wdHkgcmVzcG9uc2UuJyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB0YXNrUGFyYW1zOiBUYXNrUGFyYW1zPFQ+ID0ganNvbj8uc3RhdHVzIGFzIFRhc2tQYXJhbXM8VD47XG4gICAgbGV0IHRhc2s6IFRhc2s8VD47XG5cbiAgICBpZiAodHlwZW9mIHRhc2tQYXJhbXM/LnN0YXRlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICB0YXNrID0gbmV3IFRhc2sodGhpcywge1xuICAgICAgICAuLi50YXNrUGFyYW1zLFxuICAgICAgICByZXNwb25zZVBhdGg6IHJlc3BvbnNlUGF0aCxcbiAgICAgICAgcmF3UmVzcG9uc2U6IHJhd1Jlc3BvbnNlLFxuICAgICAgICBvYmplY3RDb25zdHJ1Y3Rvcjogb2JqZWN0Q29uc3RydWN0b3IsXG4gICAgICB9KTtcbiAgICAgIGlmICh0YXNrPy5zdGF0ZSA9PSBUYXNrU3RhdGUuZmFpbGVkKSB7XG4gICAgICAgIHRocm93IGF3YWl0IHRoaXMuX21ha2VFcnJvcih7IHRhc2sgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhc2sgPSBuZXcgVGFzayh0aGlzLCB7XG4gICAgICAgIHJlc3BvbnNlUGF0aDogcmVzcG9uc2VQYXRoLFxuICAgICAgICByYXdSZXNwb25zZTogcmF3UmVzcG9uc2UsXG4gICAgICAgIG9iamVjdENvbnN0cnVjdG9yOiBvYmplY3RDb25zdHJ1Y3RvcixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRhc2suc2V0RGF0YShqc29uPy5kYXRhKTtcbiAgICByZXR1cm4gdGFzaztcbiAgfVxuXG4gIGFzeW5jIGNhbGw8VD4oXG4gICAgdmVyYjogVmVyYixcbiAgICBvcGVyYXRpb246IHN0cmluZyxcbiAgICBwYXlsb2FkOiB1bmtub3duLFxuICAgIGNvbmZpZz86IFBvc3RDb25maWc8VD4sXG4gICAgb3ZlcnJpZGVDb25maWc/OiBDb25maWd1cmF0aW9uXG4gICk6IFByb21pc2U8QXhpb3NSZXNwb25zZSB8IFRhc2s8VD4+IHtcbiAgICAvLyBUaGlzIG92ZXJyaWRlQ29uZmlnIHZhciBpcyBuZWNlc3NhcnkgZm9yIHRoZSBzd2l0Y2ggY29uZmlnIG9wZXJhdGlvbiBhdCBpbml0XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnIHx8IChhd2FpdCB0aGlzLmNvbmZpZyk7XG4gICAgaWYgKCFiYXNlQ29uZmlnLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IFN0ZWFtc2hpcEVycm9yKHtcbiAgICAgICAgc3RhdHVzQ29kZTogJ0F1dGhlbnRpY2F0aW9uJyxcbiAgICAgICAgc3RhdHVzTWVzc2FnZTogJ0FQSSBLZXkgbm90IGZvdW5kLicsXG4gICAgICAgIHN0YXR1c1N1Z2dlc3Rpb246XG4gICAgICAgICAgJ1BsZWFzZSBzZWUgZG9jcy5zdGVhbXNoaXAuY29tIGZvciBhIHZhcmlldHkgb2Ygd2F5cyB0byBzZXQgeW91ciBBUEkga2V5LicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgdXJsID0gdGhpcy5fdXJsKGJhc2VDb25maWcsIGNvbmZpZywgb3BlcmF0aW9uKTtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5faGVhZGVycyhiYXNlQ29uZmlnLCBjb25maWcpO1xuXG4gICAgY29uc3QgcmVxQ29uZmlnID0ge1xuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIG1heENvbnRlbnRMZW5ndGg6IE1BWF9CT0RZX0xFTkdUSCxcbiAgICAgIG1heEJvZHlMZW5ndGg6IE1BWF9CT0RZX0xFTkdUSCxcbiAgICB9O1xuXG4gICAgbGV0IGZpbmFsUGF5bG9hZDogdW5kZWZpbmVkIHwgdW5rbm93biB8IHsgW2tleTogc3RyaW5nXTogdW5kZWZpbmVkIH0gPVxuICAgICAgdW5kZWZpbmVkO1xuICAgIGlmICh2ZXJiID09ICdQT1NUJyAmJiBjb25maWc/LmZpbGUpIHtcbiAgICAgIGxldCBjb250ZW50VHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLmZpbGUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGVudFR5cGUgPSAnYmluYXJ5L29jdGV0LXN0cmVhbSc7XG4gICAgICB9XG5cbiAgICAgIC8vIEltcG9ydGFudCBzbyBwcm9wZXIgYm91bmRhcnkgY2FuIGJlIHNldDtcbiAgICAgIGRlbGV0ZSByZXFDb25maWcuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG5cbiAgICAgIGlmIChpc05vZGUoKSkge1xuICAgICAgICBjb25zdCBGb3JtRGF0YU5vZGUgPSBhd2FpdCBpbXBvcnQoJ2Zvcm0tZGF0YScpO1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YU5vZGUuZGVmYXVsdCgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBCdWZmZXIuZnJvbShjb25maWcuZmlsZSBhcyBhbnkpLCB7XG4gICAgICAgICAgZmlsZW5hbWU6IGNvbmZpZz8uZmlsZW5hbWUsXG4gICAgICAgICAgY29udGVudFR5cGU6IGNvbnRlbnRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHAgPSBwYXlsb2FkIGFzIHsgW2tleTogc3RyaW5nXTogdW5kZWZpbmVkIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBwKSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHBba2V5XTtcbiAgICAgICAgICBhZGRNdWx0aXBhcnRzKGZvcm1EYXRhLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbFBheWxvYWQgPSBmb3JtRGF0YTtcblxuICAgICAgICAvLyBUaGlzIG9ubHkgbmVlZHMgdG8gaGFwcGVuIG9uIE5vZGUuXG4gICAgICAgIC8vIEFuZCB0aGUgLmdldEhlYWRlcnMgbWV0aG9kIGlzIHVuYXZpbGFiaWxlIGluIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIHVudGVzdGVkIGluIHRoZSB1bml0IHRlc3RzOyBpdCB3aWxsIHNob3cgdXAgYXMgYSBmYWlsdXJlIGluIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHN0YXJ0IHJ1bm5pbmcgdGVzdHMgaW5zaWRlIGEgYnJvd3NlciBydW50aW1lIHRvby5cbiAgICAgICAgcmVxQ29uZmlnLmhlYWRlcnMgPSB7IC4uLnJlcUNvbmZpZy5oZWFkZXJzLCAuLi5mb3JtRGF0YS5nZXRIZWFkZXJzKCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBjb25maWcuZmlsZSBhcyBhbnkgY2FzdCBiZWxvdyBpcyBiZWNhdXNlIEZvcm1EYXRhIGRvZXMgbm90IHN1cHBvcnQgQnVmZmVyLlxuICAgICAgICAgKiBJbiBnZW5lcmFsLCBmaWxlIGFzIGEgQnVmZmVyIHNob3VsZCBvbmx5IGJlIGRvbmUgZnJvbSB3aXRoaW4gdGhlIE5vZGVKUyBlbnZpcm9ubWVudCxcbiAgICAgICAgICogbm90IGZyb20gd2l0aGluIHRoZSBicm93c2VyLiBJbiB0aGUgYnJvd3NlciwgQmxvYiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBGaWd1cmUgb3V0IGlmIHRoZXJlJ3MgYSB3YXkgdG8gc3Ryb25nbHkgdHlwZSAob3IgYXQgbGVhc3QgcnVudGltZSBjaGVjaykgdGhpc1xuICAgICAgICAgKiBzbyB0aGF0IHdlIGdldCBiYWNrIGludGVsbGlnZW50IGVycm9ycyB0aGF0IGFyZSBlbnZpcm9ubWVudC1kZXBlbmRlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBjb25maWcuZmlsZSBhcyBhbnksIGNvbmZpZz8uZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCBwcCA9IHBheWxvYWQgYXMgeyBba2V5OiBzdHJpbmddOiB1bmRlZmluZWQgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocHApKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwcFtrZXldO1xuICAgICAgICAgIGFkZE11bHRpcGFydHMoZm9ybURhdGEsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsUGF5bG9hZCA9IGZvcm1EYXRhO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBheWxvYWQgPT0gJ29iamVjdCcpIHtcbiAgICAgIGZpbmFsUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5hbFBheWxvYWQgPSBwYXlsb2FkO1xuICAgIH1cblxuICAgIGxldCByZXNwOiBBeGlvc1Jlc3BvbnNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh2ZXJiID09ICdQT1NUJykge1xuICAgICAgICByZXNwID0gYXdhaXQgZG9GZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IHZlcmIsXG4gICAgICAgICAgYm9keTogZmluYWxQYXlsb2FkIGFzIGFueSxcbiAgICAgICAgICBoZWFkZXJzOiByZXFDb25maWcuaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlc3AgPSBhd2FpdCBheGlvcy5wb3N0KHVybCwgZmluYWxQYXlsb2FkLCByZXFDb25maWcpO1xuICAgICAgfSBlbHNlIGlmICh2ZXJiID09ICdHRVQnKSB7XG4gICAgICAgIC8vIFRPRE86IEluY29ycG9yYXRlIHBhcmFtcyBpbnRvIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICB1cmwgPSB1cmwgKyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHBheWxvYWQgYXMgYW55KTtcbiAgICAgICAgfVxuICAgICAgICByZXNwID0gYXdhaXQgZG9GZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IHZlcmIsXG4gICAgICAgICAgaGVhZGVyczogcmVxQ29uZmlnLmhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZXNwID0gYXdhaXQgYXhpb3MuZ2V0KHVybCwgeyAuLi5yZXFDb25maWcsIHBhcmFtczogZmluYWxQYXlsb2FkIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0ZWFtc2hpcEVycm9yKHtcbiAgICAgICAgICBzdGF0dXNNZXNzYWdlOiBgVW5zdXBwb3J0ZWQgSFRUUCBWZXJiOiAke3ZlcmJ9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgdGhyb3cgdGhpcy5fbWFrZUVycm9yKHsgZXJyb3IgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX21ha2VSZXNwb25zZSh7XG4gICAgICByZXNwb25zZTogcmVzcCxcbiAgICAgIHJhd1Jlc3BvbnNlOiBjb25maWc/LnJhd1Jlc3BvbnNlLFxuICAgICAgb2JqZWN0Q29uc3RydWN0b3I6IGNvbmZpZz8uZXhwZWN0LFxuICAgICAgcmVzcG9uc2VQYXRoOiBjb25maWc/LnJlc3BvbnNlUGF0aCxcbiAgICB9KTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBR0E7QUFRQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQW9DO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FFckJBLE9BQU87RUFBQTtBQUFBLEVBU3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7RUFBQSx5RkF4QkEsa0JBQXVCQyxHQUFRLEVBQUVDLElBQVM7SUFBQTtNQUFBO1FBQUE7VUFBQSxrQ0FDakMsSUFBQUMsaUJBQUssRUFBQztZQUNYRixHQUFHLEVBQUhBLEdBQUc7WUFDSEcsT0FBTyxFQUFFRixJQUFJLENBQUNFLE9BQU87WUFDckJDLElBQUksRUFBRUgsSUFBSSxDQUFDSSxJQUFJO1lBQ2ZDLE1BQU0sRUFBRUwsSUFBSSxDQUFDSztVQUNmLENBQUMsQ0FBQztRQUFBO1FBQUE7VUFBQTtNQUFBO0lBQUE7RUFBQSxDQUNIO0VBQUE7QUFBQTtBQW1CRCxJQUFNQyxHQUFXLEdBQUcsSUFBQUMsZUFBUyxFQUFDLG1CQUFtQixDQUFDO0FBRWxELElBQU1DLGVBQWUsR0FBRyxNQUFNLEdBQUcsSUFBSTtBQUVyQyxJQUFNQyxTQUFT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